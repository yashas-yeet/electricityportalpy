import sqlite3
import customtkinter as ctk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib
from datetime import datetime
import os 
import random # For grievance tokens
import bcrypt
import openpyxl # For Excel Export
import csv # For CSV Import

# Tell matplotlib to use the Tkinter backend
matplotlib.use("TkAgg")

def setup_database():
    conn = sqlite3.connect('electricity.db')
    cursor = conn.cursor()
    
    def add_column_if_not_exists(table, column, definition):
        cursor.execute(f"PRAGMA table_info({table})")
        columns = [info[1] for info in cursor.fetchall()]
        if column not in columns:
            print(f"Database Migration: Adding column '{column}' to table '{table}'...")
            try:
                cursor.execute(f"ALTER TABLE {table} ADD COLUMN {column} {definition}")
                print(f"Successfully added '{column}'.")
            except Exception as e:
                print(f"Error adding column {column}: {e}")
            
    def drop_table_if_exists(table):
        try:
            cursor.execute(f"DROP TABLE IF EXISTS {table}")
            print(f"Migration: Dropped obsolete table '{table}' for new schema.")
        except Exception as e:
            print(f"Error dropping table {table}: {e}")

    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        role TEXT NOT NULL CHECK(role IN ('admin', 'client')),
        full_name TEXT
    )
    ''')
    
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS consumption (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        month TEXT NOT NULL,
        usage_kwh REAL NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
        UNIQUE(user_id, month)
    )
    ''')
    
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS action_log (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp TEXT NOT NULL,
        actor TEXT NOT NULL,
        action TEXT NOT NULL
    )
    ''')
    
    # --- NEW: Grievance Ticket Table (Parent) ---
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS grievance_tickets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        token TEXT UNIQUE NOT NULL,
        user_id INTEGER NOT NULL,
        username TEXT NOT NULL,
        subject TEXT NOT NULL,
        status TEXT DEFAULT 'Pending',
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id)
    )
    ''')
    
    # --- NEW: Grievance Messages Table (Child) ---
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS grievance_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        ticket_id INTEGER NOT NULL,
        sender_id INTEGER NOT NULL,
        sender_name TEXT NOT NULL,
        message TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        FOREIGN KEY (ticket_id) REFERENCES grievance_tickets (id) ON DELETE CASCADE,
        FOREIGN KEY (sender_id) REFERENCES users (id)
    )
    ''')
    
    # --- Migration: Drop old 'grievances' table if it exists ---
    drop_table_if_exists('grievances')

    try:
        add_column_if_not_exists('consumption', 'total_bill', 'REAL DEFAULT 0.0')
        add_column_if_not_exists('consumption', 'bill_status', "TEXT DEFAULT 'Pending'")
        add_column_if_not_exists('consumption', 'payment_timestamp', 'TEXT')
    except Exception as e:
        print(f"Error during database migration: {e}")
    
    admin_pass = b'admin123'
    hashed_admin_pass = bcrypt.hashpw(admin_pass, bcrypt.gensalt()).decode('utf-8')
    
    try:
        cursor.execute(
            "INSERT INTO users (username, password, role, full_name) VALUES (?, ?, ?, ?)",
            ('admin', hashed_admin_pass, 'admin', 'Administrator')
        )
    except sqlite3.IntegrityError:
        pass 

    conn.commit()
    conn.close()

def db_query(query, params=()):
    conn = sqlite3.connect('electricity.db')
    cursor = conn.cursor()
    try:
        cursor.execute(query, params)
        conn.commit()
    except Exception as e:
        print(f"DB Query Error: {e}")
    finally:
        conn.close()

def db_query_lastrowid(query, params=()):
    conn = sqlite3.connect('electricity.db')
    cursor = conn.cursor()
    last_id = None
    try:
        cursor.execute(query, params)
        last_id = cursor.lastrowid
        conn.commit()
    except Exception as e:
        print(f"DB Query Error: {e}")
    finally:
        conn.close()
    return last_id

def db_query_to_df(query, params=()):
    conn = sqlite3.connect('electricity.db')
    try:
        df = pd.read_sql_query(query, conn, params=params)
    except Exception as e:
        print(f"DB Read Error: {e}")
        df = pd.DataFrame() 
    finally:
        conn.close()
    return df

def log_action(actor, action):
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        db_query("INSERT INTO action_log (timestamp, actor, action) VALUES (?, ?, ?)", (now, actor, action))
    except Exception as e:
        print(f"Failed to log action: {e}")

FIXED_CHARGE_SINGLE_PHASE = 115.00
WHEELING_CHARGE_PER_KWH = 1.40
FAC_PER_KWH = 0.00
ELECTRICITY_DUTY_RATE = 0.16
slabs = [
    (100, 3.46),  # 0-100 kWh (width 100)
    (200, 7.43),  # 101-300 kWh (width 200)
    (200, 10.32), # 301-500 kWh (width 200)
    (500, 11.71), # 501-1000 kWh (width 500)
    (float('inf'), 11.71) # >1000 kWh (infinite width)
]
    
def calculate_mahadiscom_bill(kwh_units):
    bill = {}
    bill_details = []
    energy_charge = 0.0
    remaining_units = kwh_units
    
    slab_labels = [
        "  - 0-100 kWh:",
        "  - 101-300 kWh:",
        "  - 301-500 kWh:",
        "  - 501-1000 kWh:",
        "  - >1000 kWh:"
    ]
    
    for i, (slab_width, rate) in enumerate(slabs):
        if remaining_units <= 0:
            break
            
        units_in_this_slab = min(remaining_units, slab_width)
        slab_cost = units_in_this_slab * rate
        energy_charge += slab_cost
        remaining_units -= units_in_this_slab
        
        label = slab_labels[i] if i < len(slab_labels) else "  - Other:"
        bill_details.append(f"{label} {units_in_this_slab:>6.2f} kWh @ ‚Çπ{rate:.2f}/unit = ‚Çπ{slab_cost:.2f}")

    bill['A_Energy_Charge'] = energy_charge
    bill['B_Fixed_Charge'] = FIXED_CHARGE_SINGLE_PHASE
    bill['C_Wheeling_Charge'] = kwh_units * WHEELING_CHARGE_PER_KWH
    bill['D_FAC'] = kwh_units * FAC_PER_KWH
    sub_total = (bill['A_Energy_Charge'] + bill['B_Fixed_Charge'] + 
                 bill['C_Wheeling_Charge'] + bill['D_FAC'])
    bill['E_Electricity_Duty'] = sub_total * ELECTRICITY_DUTY_RATE
    bill['F_Total_Bill'] = sub_total + bill['E_Electricity_Duty']
    
    return bill, bill_details


# --- ALL DIALOG (POP-UP) CLASSES ---
# --- MOVED HERE TO FIX 'not defined' ERROR ---

class ChangePasswordDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        
        self.title("Change Password")
        self.geometry("350x300")
        
        self.font_normal = self.controller.font_normal
        self.font_bold = self.controller.font_bold_large

        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        ctk.CTkLabel(main_frame, text="Change Your Password", font=self.font_bold).pack(pady=(0, 15))
        
        ctk.CTkLabel(main_frame, text="Current Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.current_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.current_pass_entry.pack(pady=(0, 10), padx=10)
        
        ctk.CTkLabel(main_frame, text="New Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.new_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.new_pass_entry.pack(pady=(0, 10), padx=10)

        ctk.CTkLabel(main_frame, text="Confirm New Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.confirm_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.confirm_pass_entry.pack(pady=(0, 20), padx=10)
        
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack()

        save_button = ctk.CTkButton(button_frame, text="Save Password", command=self.save_password)
        save_button.pack(side="left", padx=10)
        
        cancel_button = ctk.CTkButton(button_frame, text="Cancel", command=self.destroy, fg_color="gray")
        cancel_button.pack(side="left", padx=10)
        
        self.after(100, self.lift) 
        self.grab_set()
        self.current_pass_entry.focus()

    def save_password(self):
        current_pass = self.current_pass_entry.get()
        new_pass = self.new_pass_entry.get()
        confirm_pass = self.confirm_pass_entry.get()
        
        if not current_pass or not new_pass or not confirm_pass:
            messagebox.showerror("Error", "All fields are required.", parent=self)
            return
        if new_pass != confirm_pass:
            messagebox.showerror("Error", "New passwords do not match.", parent=self)
            return
        if current_pass == new_pass:
            messagebox.showerror("Error", "New password must be different from the current password.", parent=self)
            return

        user_id = self.controller.current_user_id
        user_df = db_query_to_df("SELECT password FROM users WHERE id = ?", params=(user_id,))
        
        if user_df.empty:
            messagebox.showerror("Error", "Could not find user record.", parent=self)
            return
            
        stored_hash = user_df.iloc[0]['password'].encode('utf-8')
        
        if not bcrypt.checkpw(current_pass.encode('utf-8'), stored_hash):
            messagebox.showerror("Error", "Your 'Current Password' is incorrect.", parent=self)
            log_action(self.controller.current_user_name, "Failed password change (wrong current pass).")
            return
            
        try:
            new_hashed_pass = bcrypt.hashpw(new_pass.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            db_query("UPDATE users SET password = ? WHERE id = ?", (new_hashed_pass, user_id))
            
            log_action(self.controller.current_user_name, "Changed their password successfully.")
            messagebox.showinfo("Success", "Password changed successfully.", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}", parent=self)

class ResetPasswordDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller, user_id, username):
        super().__init__(parent)
        self.controller = controller
        self.user_id = user_id
        
        self.title("Reset Password")
        self.geometry("350x250")
        
        self.font_normal = self.controller.font_normal
        self.font_bold = self.controller.font_bold_large

        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        ctk.CTkLabel(main_frame, text="Reset Password", font=self.font_bold).pack(pady=(0, 10))
        ctk.CTkLabel(main_frame, text=f"User: {username}", font=self.font_normal).pack(pady=(0, 15))
        
        ctk.CTkLabel(main_frame, text="New Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.new_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.new_pass_entry.pack(pady=(0, 10), padx=10)

        ctk.CTkLabel(main_frame, text="Confirm New Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.confirm_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.confirm_pass_entry.pack(pady=(0, 20), padx=10)
        
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack()

        save_button = ctk.CTkButton(button_frame, text="Set Password", command=self.save_password)
        save_button.pack(side="left", padx=10)
        
        cancel_button = ctk.CTkButton(button_frame, text="Cancel", command=self.destroy, fg_color="gray")
        cancel_button.pack(side="left", padx=10)
        
        self.after(100, self.lift) 
        self.grab_set()
        self.new_pass_entry.focus()

    def save_password(self):
        new_pass = self.new_pass_entry.get()
        confirm_pass = self.confirm_pass_entry.get()
        
        if not new_pass or not confirm_pass:
            messagebox.showerror("Error", "All fields are required.", parent=self)
            return
        if new_pass != confirm_pass:
            messagebox.showerror("Error", "New passwords do not match.", parent=self)
            return
            
        try:
            new_hashed_pass = bcrypt.hashpw(new_pass.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            db_query("UPDATE users SET password = ? WHERE id = ?", (new_hashed_pass, self.user_id))
            
            log_action(self.controller.current_user_name, f"Reset password for user ID {self.user_id}.")
            messagebox.showinfo("Success", "Password has been reset successfully.", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}", parent=self)

class UpdateUserDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller, user_id, username, full_name):
        super().__init__(parent)
        self.controller = controller
        self.user_id = user_id
        
        self.title("Update User Info")
        self.geometry("350x250")
        
        self.font_normal = self.controller.font_normal
        self.font_bold = self.controller.font_bold_large

        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        ctk.CTkLabel(main_frame, text="Update User Info", font=self.font_bold).pack(pady=(0, 15))
        
        ctk.CTkLabel(main_frame, text="Full Name:", font=self.font_normal).pack(anchor="w", padx=10)
        self.full_name_entry = ctk.CTkEntry(main_frame, width=250)
        self.full_name_entry.insert(0, full_name)
        self.full_name_entry.pack(pady=(0, 10), padx=10)

        ctk.CTkLabel(main_frame, text="Username:", font=self.font_normal).pack(anchor="w", padx=10)
        self.username_entry = ctk.CTkEntry(main_frame, width=250)
        self.username_entry.insert(0, username)
        self.username_entry.pack(pady=(0, 20), padx=10)
        
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack()

        save_button = ctk.CTkButton(button_frame, text="Save Changes", command=self.save_changes)
        save_button.pack(side="left", padx=10)
        
        cancel_button = ctk.CTkButton(button_frame, text="Cancel", command=self.destroy, fg_color="gray")
        cancel_button.pack(side="left", padx=10)
        
        self.after(100, self.lift)
        self.grab_set()
        self.full_name_entry.focus()

    def save_changes(self):
        new_full_name = self.full_name_entry.get()
        new_username = self.username_entry.get()
        
        if not new_full_name or not new_username:
            messagebox.showerror("Error", "All fields are required.", parent=self)
            return
            
        try:
            db_query("UPDATE users SET full_name = ?, username = ? WHERE id = ?", (new_full_name, new_username, self.user_id))
            log_action(self.controller.current_user_name, f"Updated info for user ID {self.user_id}.")
            messagebox.showinfo("Success", "User information updated successfully.", parent=self)
            self.controller.frames["AdminView"].refresh_user_list()
            self.destroy()
        except sqlite3.IntegrityError:
            messagebox.showerror("Error", "That username is already taken.", parent=self)
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}", parent=self)

class BillViewDialog(ctk.CTkToplevel):
    def __init__(self, parent, title, bill_text):
        super().__init__(parent)
        self.title(title)
        self.geometry("600x700")
        
        font_mono = ctk.CTkFont(family="Courier", size=14)
        
        textbox = ctk.CTkTextbox(self, font=font_mono, wrap="word")
        textbox.pack(fill="both", expand=True, padx=10, pady=10)
        
        textbox.insert("1.0", bill_text)
        textbox.configure(state="disabled")
        
        close_button = ctk.CTkButton(self, text="Close", command=self.destroy)
        close_button.pack(pady=10)
        
        self.after(100, self.lift)
        self.grab_set()

class GrievanceViewDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller, ticket_id, subject):
        super().__init__(parent)
        self.controller = controller
        self.ticket_id = ticket_id
        
        self.title(f"Ticket: {subject}")
        self.geometry("500x600")
        
        # --- FIX: Changed parent.controller to parent ---
        self.font_normal = parent.font_normal
        self.font_bold = parent.font_normal_bold
        self.font_small = parent.font_small
        # --- END FIX ---

        self.chat_frame_wrapper = ctk.CTkFrame(self, fg_color="transparent")
        self.chat_frame_wrapper.pack(fill="both", expand=True, padx=10, pady=10)
        self.chat_frame_wrapper.grid_rowconfigure(0, weight=1)
        self.chat_frame_wrapper.grid_columnconfigure(0, weight=1)

        self.chat_frame = ctk.CTkScrollableFrame(self.chat_frame_wrapper)
        self.chat_frame.grid(row=0, column=0, sticky="nsew")

        self.reply_entry = ctk.CTkTextbox(self, height=100, font=self.font_normal)
        self.reply_entry.pack(fill="x", padx=10, pady=(0, 5))
        
        self.send_button = ctk.CTkButton(self, text="‚úâÔ∏è Send Reply", font=self.font_normal, command=self.send_reply)
        self.send_button.pack(pady=(0, 10))
        
        self.chat_frame.bind_all("<MouseWheel>", lambda event: self.chat_frame._parent_canvas.yview_scroll(int(-1*(event.delta/120)), "units"), add="+")

        self.load_chat_history()
        self.check_ticket_status()
        
        self.after(100, self.lift)
        self.grab_set()
        
    def load_chat_history(self):
        for widget in self.chat_frame.winfo_children():
            widget.destroy()
            
        messages_df = db_query_to_df("SELECT sender_name, timestamp, message FROM grievance_messages WHERE ticket_id = ? ORDER BY timestamp ASC",
                                     params=(self.ticket_id,))
        
        if messages_df.empty:
            ctk.CTkLabel(self.chat_frame, text="No messages found for this ticket.", font=self.font_normal).pack(anchor="w")
        else:
            for index, row in messages_df.iterrows():
                header = f"--- {row['sender_name']} ({row['timestamp']}) ---\n"
                message = f"{row['message']}\n\n"
                
                msg_frame = ctk.CTkFrame(self.chat_frame, fg_color="transparent")
                msg_label = ctk.CTkLabel(msg_frame, text=header+message, font=self.font_normal, justify="left", wraplength=400)
                
                # Align user's messages to the right
                if row['sender_name'] == self.controller.current_user_name:
                    msg_label.pack(anchor="e", padx=5, pady=0)
                    msg_frame.pack(fill="x", anchor="e", padx=5, pady=2)
                else:
                    msg_label.pack(anchor="w", padx=5, pady=0)
                    msg_frame.pack(fill="x", anchor="w", padx=5, pady=2)

        self.after(100, self.chat_frame._parent_canvas.yview_moveto, 1.0) # Scroll to bottom

    def send_reply(self):
        reply_text = self.reply_entry.get("1.0", "end-1c").strip()
        if not reply_text:
            messagebox.showerror("Error", "Cannot send an empty message.", parent=self)
            return
            
        try:
            sender_id = self.controller.current_user_id
            sender_name = self.controller.current_user_name
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            db_query("INSERT INTO grievance_messages (ticket_id, sender_id, sender_name, message, timestamp) VALUES (?, ?, ?, ?, ?)",
                     (self.ticket_id, sender_id, sender_name, reply_text, timestamp))
            
            # Set status to 'Pending' (or 'Answered' if admin replied)
            new_status = 'Pending' if self.controller.current_user_role == 'admin' else 'Pending' 
            db_query("UPDATE grievance_tickets SET status = ?, updated_at = ? WHERE id = ?", (new_status, timestamp, self.ticket_id))
            
            log_action(sender_name, f"Replied to grievance ticket ID {self.ticket_id}.")
            self.reply_entry.delete("1.0", "end")
            self.load_chat_history()
            
            # Refresh the list in the main app window
            if self.controller.current_user_role == 'admin':
                self.controller.frames["AdminView"].refresh_grievance_list()
            else:
                self.controller.frames["ClientView"].refresh_grievance_list()
                
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}", parent=self)

    def check_ticket_status(self):
        status_df = db_query_to_df("SELECT status FROM grievance_tickets WHERE id = ?", params=(self.ticket_id,))
        if not status_df.empty and status_df.iloc[0]['status'] == 'Resolved':
            self.reply_entry.insert("1.0", "This ticket is marked as 'Resolved' and can no longer be replied to.")
            self.reply_entry.configure(state="disabled")
            self.send_button.configure(state="disabled")


# --- MAIN APP FRAMES ---

class ElectricityPortalApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        
        self.title("Electricity Portal")
        self.geometry("1100x800")
        
        self.font_normal = ctk.CTkFont(family="Bahnschrift", size=14)
        self.font_bold = ctk.CTkFont(family="Bahnschrift", size=18, weight="bold")
        self.font_bold_large = ctk.CTkFont(family="Bahnschrift", size=24, weight="bold")
        self.font_title = ctk.CTkFont(family="Bahnschrift", size=28, weight="bold")
        self.font_normal_bold = ctk.CTkFont(family="Bahnschrift", size=14, weight="bold")
        self.font_small = ctk.CTkFont(family="Bahnschrift", size=12)
        
        style = ttk.Style()
        style.configure("Treeview.Heading", font=("Bahnschrift", 14, "bold"))
        style.configure("Treeview", font=("Bahnschrift", 13), rowheight=28)
        
        self.chart_light_style = {
            'figure.facecolor': '#ebebeb', 'axes.facecolor': '#ffffff',
            'text.color': '#1c1c1c', 'axes.labelcolor': '#1c1c1c',
            'xtick.color': '#1c1c1c', 'ytick.color': '#1c1c1c', 'axes.edgecolor': '#1c1c1c'
        }
        self.chart_dark_style = {
            'figure.facecolor': '#2b2b2b', 'axes.facecolor': '#3c3c3c',
            'text.color': '#dce4ee', 'axes.labelcolor': '#dce4ee',
            'xtick.color': '#dce4ee', 'ytick.color': '#dce4ee', 'axes.edgecolor': '#dce4ee'
        }

        self.current_user_id = None
        self.current_user_role = None
        self.current_user_name = None

        title_label = ctk.CTkLabel(self, text="ELECTRICITY DISTRIBUTION PORTAL", 
                                   font=self.font_title)
        title_label.pack(side="top", pady=(20, 10))

        container = ctk.CTkFrame(self)
        container.pack(side="top", fill="both", expand=True)
        container.grid_rowconfigure(0, weight=1)
        container.grid_columnconfigure(0, weight=1)

        self.frames = {}
        for F in (LoginView, AdminView, ClientView, RegisterView):
            page_name = F.__name__
            frame = F(parent=container, controller=self)
            self.frames[page_name] = frame
            frame.grid(row=0, column=0, sticky="nsew")

        self.show_frame("LoginView")
        self.update_chart_styles()

    def show_frame(self, page_name):
        frame = self.frames[page_name]
        if page_name == "AdminView":
            frame.refresh_data()
        if page_name == "ClientView":
            frame.refresh_data()
        frame.tkraise()
        
    def logout(self):
        actor = self.current_user_name if self.current_user_name else "Unknown"
        log_action(actor, "Logged out.")
        self.current_user_id = None
        self.current_user_role = None
        self.current_user_name = None
        self.show_frame("LoginView")
        
    def update_chart_styles(self):
        mode = ctk.get_appearance_mode()
        style_dict = self.chart_light_style if mode == "Light" else self.chart_dark_style
        for key, value in style_dict.items():
            plt.rcParams[key] = value
        for frame in self.frames.values():
            if hasattr(frame, 'update_charts'):
                frame.update_charts()
    
    def generate_bill_text(self, kwh_units, month, user_name):
        try:
            bill_data, bill_details = calculate_mahadiscom_bill(kwh_units)
            bill_text = f"--- ESTIMATED ELECTRICITY BILL ---\n\n"
            bill_text += f"Client: {user_name}\n"
            bill_text += f"Billing Month: {month}\n"
            bill_text += f"Total Consumption: {kwh_units:.2f} kWh\n"
            bill_text += "----------------------------------\n\n"
            bill_text += "ITEMIZED CHARGES:\n\n"
            bill_text += f"A. Energy Charges:\n"
            bill_text += "\n".join(bill_details) + "\n"
            bill_text += f"   Total Energy Charge:   ‚Çπ{bill_data['A_Energy_Charge']:>10.2f}\n\n"
            bill_text += f"B. Fixed Charge:             ‚Çπ{bill_data['B_Fixed_Charge']:>10.2f}\n"
            bill_text += f"C. Wheeling Charge:          ‚Çπ{bill_data['C_Wheeling_Charge']:>10.2f}\n"
            bill_text += f"D. Fuel Adjustment (FAC):    ‚Çπ{bill_data['D_FAC']:>10.2f}\n"
            bill_text += "----------------------------------\n"
            sub_total = bill_data['A_Energy_Charge'] + bill_data['B_Fixed_Charge'] + bill_data['C_Wheeling_Charge'] + bill_data['D_FAC']
            bill_text += f"   Sub-Total:               ‚Çπ{sub_total:>10.2f}\n"
            bill_text += f"E. Electricity Duty (16%):   ‚Çπ{bill_data['E_Electricity_Duty']:>10.2f}\n\n"
            bill_text += f"--- TOTAL BILL AMOUNT ---\n"
            bill_text += f"   (A+B+C+D+E):             ‚Çπ{bill_data['F_Total_Bill']:>10.2f}\n"
            bill_text += "----------------------------------\n"
            bill_text += "\n\n--- APPLIED TARIFF (Residential LT-I) ---\n"
            bill_text += f"Fixed Charge:      ‚Çπ{FIXED_CHARGE_SINGLE_PHASE:.2f}/month\n"
            bill_text += f"Wheeling Charge:   ‚Çπ{WHEELING_CHARGE_PER_KWH:.2f}/kWh\n"
            bill_text += f"Electricity Duty:  {ELECTRICITY_DUTY_RATE * 100:.0f}%\n"
            bill_text += "Energy Charges (Telescopic Slabs):\n"
            bill_text += f"  - 0-100 kWh:       ‚Çπ{slabs[0][1]:.2f}/unit\n"
            bill_text += f"  - 101-300 kWh:     ‚Çπ{slabs[1][1]:.2f}/unit\n"
            bill_text += f"  - 301-500 kWh:     ‚Çπ{slabs[2][1]:.2f}/unit\n"
            bill_text += f"  - 501-1000 kWh:    ‚Çπ{slabs[3][1]:.2f}/unit\n"
            bill_text += f"  - >1000 kWh:       ‚Çπ{slabs[4][1]:.2f}/unit\n"
            return bill_text
        except Exception as e:
            return f"An error occurred during bill calculation: {e}"

    def show_bill_popup(self, bill_text, title="View Bill"):
        if hasattr(self, 'bill_dialog') and self.bill_dialog.winfo_exists():
            self.bill_dialog.focus()
            return
            
        self.bill_dialog = BillViewDialog(parent=self, title=title, bill_text=bill_text)
        self.bill_dialog.grab_set()

    def show_grievance_popup(self, ticket_id, subject):
        if hasattr(self, 'grievance_dialog') and self.grievance_dialog.winfo_exists():
            self.grievance_dialog.focus()
            return
        
        self.grievance_dialog = GrievanceViewDialog(parent=self, 
                                                    controller=self,
                                                    ticket_id=ticket_id, 
                                                    subject=subject)
        self.grievance_dialog.grab_set()


class LoginView(ctk.CTkFrame):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        
        self.configure(fg_color="transparent")
        frame = ctk.CTkFrame(self, width=300, height=350) 
        frame.place(relx=0.5, rely=0.5, anchor="center")
        
        label = ctk.CTkLabel(frame, text="Portal Login", font=controller.font_bold_large)
        label.pack(pady=20, padx=30)
        
        self.username_entry = ctk.CTkEntry(frame, placeholder_text="Username", width=200, font=controller.font_normal)
        self.username_entry.pack(pady=10, padx=30)
        
        self.password_entry = ctk.CTkEntry(frame, placeholder_text="Password", show="*", width=200, font=controller.font_normal)
        self.password_entry.pack(pady=10, padx=30)
        
        self.show_pass_check = ctk.CTkCheckBox(frame, text="Show Password",
                                               font=controller.font_small,
                                               command=self.toggle_password_visibility)
        self.show_pass_check.pack(pady=5, padx=30, anchor="w")
        
        self.password_entry.bind("<Return>", self.handle_login)
        
        login_button = ctk.CTkButton(frame, text="üîë Login", command=self.handle_login, width=200, font=controller.font_normal)
        login_button.pack(pady=20, padx=30)
        
        register_button = ctk.CTkButton(frame, text="Register as New User",
                                        command=lambda: controller.show_frame("RegisterView"),
                                        width=200, font=controller.font_normal,
                                        fg_color="transparent", border_width=1,
                                        text_color=("gray10", "gray90"))
        register_button.pack(pady=(0, 20), padx=30)
        
        def change_mode(value):
            ctk.set_appearance_mode(value)
            controller.update_chart_styles() 
        
        mode_switch = ctk.CTkSegmentedButton(self, values=["Light", "Dark", "System"],
                                             command=change_mode,
                                             font=controller.font_small)
        mode_switch.set(ctk.get_appearance_mode())
        mode_switch.pack(side="bottom", pady=20, padx=10)
        mode_label = ctk.CTkLabel(self, text="Appearance Mode", font=controller.font_small)
        mode_label.pack(side="bottom", pady=0, padx=10)

    def toggle_password_visibility(self):
        if self.show_pass_check.get() == 1:
            self.password_entry.configure(show="")
        else:
            self.password_entry.configure(show="*")

    def handle_login(self, event=None):
        username = self.username_entry.get()
        password = self.password_entry.get()

        if not username or not password:
            messagebox.showerror("Error", "Please enter username and password")
            return
        
        user_df = db_query_to_df("SELECT id, password, role, full_name FROM users WHERE username = ?", params=(username,))

        if not user_df.empty:
            user = user_df.iloc[0]
            stored_hash = user['password']
            
            if isinstance(stored_hash, str):
                stored_hash_bytes = stored_hash.encode('utf-8')
            elif isinstance(stored_hash, bytes):
                stored_hash_bytes = stored_hash
            else:
                log_action(username, "Failed login (invalid hash format in DB).")
                messagebox.showerror("Login Failed", "Invalid password format in database. Please contact admin.")
                return

            entered_pass_bytes = password.encode('utf-8')
            
            is_correct = False
            try:
                # Check for new hashed password
                if bcrypt.checkpw(entered_pass_bytes, stored_hash_bytes):
                    is_correct = True
            except ValueError:
                # This block catches errors if stored_hash is not a valid hash
                # (e.g., it's a plain-text password from an old DB)
                if password == stored_hash:
                    is_correct = True
                    log_action(username, "Logged in with a legacy plain-text password.")
            except Exception as e:
                # Other bcrypt errors
                print(f"Bcrypt error: {e}")
                is_correct = False

            if is_correct:
                log_action(username, "Logged in successfully.")
                self.controller.current_user_id = int(user['id'])
                self.controller.current_user_role = user['role']
                self.controller.current_user_name = user['full_name']
                self.password_entry.delete(0, 'end')
                self.username_entry.delete(0, 'end')
                self.show_pass_check.deselect()
                self.toggle_password_visibility()
                if user['role'] == 'admin':
                    self.controller.show_frame("AdminView")
                else:
                    self.controller.show_frame("ClientView")
                return

        log_action(username, "Failed login attempt (invalid username/password).")
        messagebox.showerror("Login Failed", "Invalid username or password")

class RegisterView(ctk.CTkFrame):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        
        self.configure(fg_color="transparent")
        frame = ctk.CTkFrame(self, width=300, height=450)
        frame.place(relx=0.5, rely=0.5, anchor="center")

        label = ctk.CTkLabel(frame, text="Register New Client", font=controller.font_bold_large)
        label.pack(pady=20, padx=30)

        self.full_name_entry = ctk.CTkEntry(frame, placeholder_text="Full Name", width=200, font=controller.font_normal)
        self.full_name_entry.pack(pady=10, padx=30)

        self.username_entry = ctk.CTkEntry(frame, placeholder_text="Username", width=200, font=controller.font_normal)
        self.username_entry.pack(pady=10, padx=30)

        self.password_entry = ctk.CTkEntry(frame, placeholder_text="Password", show="*", width=200, font=controller.font_normal)
        self.password_entry.pack(pady=10, padx=30)
        
        self.confirm_password_entry = ctk.CTkEntry(frame, placeholder_text="Confirm Password", show="*", width=200, font=controller.font_normal)
        self.confirm_password_entry.pack(pady=10, padx=30)

        register_button = ctk.CTkButton(frame, text="Register", command=self.handle_register, width=200, font=controller.font_normal)
        register_button.pack(pady=20, padx=30)
        
        login_button = ctk.CTkButton(frame, text="Back to Login",
                                     command=lambda: controller.show_frame("LoginView"),
                                     width=200, font=controller.font_normal,
                                     fg_color="transparent", border_width=1,
                                     text_color=("gray10", "gray90"))
        login_button.pack(pady=(0, 20), padx=30)

    def handle_register(self):
        full_name = self.full_name_entry.get()
        username = self.username_entry.get()
        password = self.password_entry.get()
        confirm_password = self.confirm_password_entry.get()

        if not full_name or not username or not password or not confirm_password:
            messagebox.showerror("Error", "All fields are required.")
            return

        if password != confirm_password:
            messagebox.showerror("Error", "Passwords do not match.")
            return

        try:
            hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            db_query(
                "INSERT INTO users (username, password, role, full_name) VALUES (?, ?, ?, ?)",
                (username, hashed_password, 'client', full_name)
            )
            log_action(username, "Registered new client account.")
            messagebox.showinfo("Success", f"User '{username}' registered successfully!\nYou can now log in.")
            
            self.full_name_entry.delete(0, 'end')
            self.username_entry.delete(0, 'end')
            self.password_entry.delete(0, 'end')
            self.confirm_password_entry.delete(0, 'end')
            self.controller.show_frame("LoginView")

        except sqlite3.IntegrityError:
            log_action(username, "Registration failed (username taken).")
            messagebox.showerror("Error", "That username is already taken. Please choose another.")
        except Exception as e:
            log_action(username, f"Registration failed (unknown error: {e}).")
            messagebox.showerror("Error", f"An error occurred: {e}")

class AdminView(ctk.CTkFrame):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        
        self.pie_fig = None
        self.pie_canvas = None
        self.line_fig = None
        self.line_canvas = None
        
        self.user_sort_column = "role"
        self.user_sort_reverse = False
        
        self.client_checkbox_widgets = [] 
        
        font_normal = controller.font_normal
        font_bold = controller.font_bold

        change_pass_button = ctk.CTkButton(self, text="Change Password", command=self.open_change_password_dialog, width=140, font=font_normal)
        change_pass_button.place(relx=0.86, rely=0.02, anchor="ne")
        
        logout_button = ctk.CTkButton(self, text="Logout ‚û°Ô∏è", command=controller.logout, width=100, font=font_normal)
        logout_button.place(relx=0.98, rely=0.02, anchor="ne")
        
        self.welcome_label = ctk.CTkLabel(self, text="Admin Dashboard", font=font_bold)
        self.welcome_label.place(relx=0.02, rely=0.02, anchor="nw")
        
        self.tab_view = ctk.CTkTabview(self)
        self.tab_view.place(relx=0.5, rely=0.53, relwidth=0.98, relheight=0.88, anchor="center") 
        self.tab_view._segmented_button.configure(font=font_normal)
        
        self.tab_view.add("Manage Users")
        self.tab_view.add("View Consumption")
        self.tab_view.add("Billing")
        self.tab_view.add("Site-Wide Analytics") 
        self.tab_view.add("Compare Clients") 
        self.tab_view.add("Grievances") 
        self.tab_view.add("Action Log") 

        self.create_manage_users_tab(self.tab_view.tab("Manage Users"))
        self.create_view_consumption_tab(self.tab_view.tab("View Consumption"))
        self.create_billing_tab(self.tab_view.tab("Billing"))
        self.create_analytics_tab(self.tab_view.tab("Site-Wide Analytics")) 
        self.create_compare_tab(self.tab_view.tab("Compare Clients")) 
        self.create_grievance_tab(self.tab_view.tab("Grievances")) 
        self.create_log_tab(self.tab_view.tab("Action Log")) 

    def open_change_password_dialog(self):
        if hasattr(self, 'password_dialog') and self.password_dialog.winfo_exists():
            self.password_dialog.focus()
        else:
            self.password_dialog = ChangePasswordDialog(parent=self, controller=self.controller)
            self.password_dialog.grab_set() 

    def create_manage_users_tab(self, tab):
        font_normal = self.controller.font_normal
        add_frame = ctk.CTkFrame(tab)
        add_frame.pack(side="top", fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(add_frame, text="Add New User:", font=font_normal).pack(side="left", padx=10)
        self.user_name_entry = ctk.CTkEntry(add_frame, placeholder_text="Full Name", font=font_normal, width=150)
        self.user_name_entry.pack(side="left", padx=5)
        self.user_user_entry = ctk.CTkEntry(add_frame, placeholder_text="Username", font=font_normal, width=150)
        self.user_user_entry.pack(side="left", padx=5)
        self.user_pass_entry = ctk.CTkEntry(add_frame, placeholder_text="Password", font=font_normal, width=150)
        self.user_pass_entry.pack(side="left", padx=5)
        self.role_menu = ctk.CTkOptionMenu(add_frame, values=["client", "admin"], width=90, font=font_normal)
        self.role_menu.set("client")
        self.role_menu.pack(side="left", padx=5)
        add_button = ctk.CTkButton(add_frame, text="üë§ Add User", width=100, command=self.add_user, font=font_normal)
        add_button.pack(side="left", padx=10)
        
        search_frame = ctk.CTkFrame(tab)
        search_frame.pack(side="top", fill="x", padx=10, pady=5)
        self.user_search_entry = ctk.CTkEntry(search_frame, placeholder_text="Search by Name or Username...", 
                                              font=font_normal, width=300)
        self.user_search_entry.pack(side="left", padx=(5, 10))
        self.user_search_entry.bind("<KeyRelease>", self.filter_user_list_event)
        
        export_button = ctk.CTkButton(search_frame, text="üìÑ Export to Excel", width=120,
                                      font=font_normal, command=self.export_users_to_excel)
        export_button.pack(side="left", padx=(20, 5))

        list_frame = ctk.CTkFrame(tab)
        list_frame.pack(side="top", fill="both", expand=True, padx=10, pady=10)
        
        columns = ("id", "username", "full_name", "role", "total_usage")
        self.user_tree = ttk.Treeview(list_frame, columns=columns, show="headings") 
        for col in columns:
            col_text = col.replace("_", " ").title()
            self.user_tree.heading(col, text=col_text, 
                                   command=lambda c=col: self.sort_user_table(c))
        self.user_tree.column("id", width=50, stretch=False)
        self.user_tree.column("username", width=150)
        self.user_tree.column("full_name", width=200)
        self.user_tree.column("role", width=80, stretch=False) 
        self.user_tree.column("total_usage", width=120, stretch=False)
        
        self.user_tree.pack(side="left", fill="both", expand=True)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.user_tree.yview)
        self.user_tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        
        button_frame = ctk.CTkFrame(tab)
        button_frame.pack(side="bottom", fill="x", padx=10, pady=5)
        
        remove_button = ctk.CTkButton(button_frame, text="üóëÔ∏è Remove Selected", command=self.remove_user, font=font_normal)
        remove_button.pack(side="left", padx=10, pady=5)
        
        update_button = ctk.CTkButton(button_frame, text="‚úèÔ∏è Update Info", command=self.open_update_user_dialog, font=font_normal)
        update_button.pack(side="left", padx=10, pady=5)
        
        reset_pass_button = ctk.CTkButton(button_frame, text="üîë Reset Password", command=self.open_reset_password_dialog, font=font_normal)
        reset_pass_button.pack(side="left", padx=10, pady=5)
        
        sort_usage_button = ctk.CTkButton(button_frame, text="Sort by Usage üìä", width=150,
                                          font=font_normal, command=self.sort_by_total_usage)
        sort_usage_button.pack(side="right", padx=10, pady=5)

    def create_view_consumption_tab(self, tab):
        font_normal = self.controller.font_normal
        font_normal_bold = self.controller.font_normal_bold
        
        top_frame = ctk.CTkFrame(tab)
        top_frame.pack(side="top", fill="x", padx=10, pady=10)
        ctk.CTkLabel(top_frame, text="Select Client:", font=font_normal).pack(side="left", padx=5)
        
        self.client_select_menu = ctk.CTkComboBox(top_frame, values=["Loading..."], 
                                                  command=self.load_client_consumption, 
                                                  font=font_normal, width=200)
        self.client_select_menu.pack(side="left", padx=5)
        
        self.consumption_stats_label = ctk.CTkLabel(top_frame, text="Client Total: 0 kWh | Avg: 0 kWh/month", font=font_normal_bold)
        self.consumption_stats_label.pack(side="right", padx=20)
        
        self.total_label = ctk.CTkLabel(top_frame, text="Total All Consumption: ...", font=font_normal_bold)
        self.total_label.pack(side="right", padx=20)

        search_frame = ctk.CTkFrame(tab)
        search_frame.pack(side="top", fill="x", padx=10, pady=(5, 0))
        
        self.month_search_entry = ctk.CTkEntry(search_frame, placeholder_text="Search by Month (e.g., 2025-09)", 
                                               font=font_normal, width=200)
        self.month_search_entry.pack(side="left", padx=(5, 10))
        
        search_button = ctk.CTkButton(search_frame, text="üîç Search", width=80, 
                                      font=font_normal, command=self.search_consumption)
        search_button.pack(side="left", padx=5)
        
        clear_button = ctk.CTkButton(search_frame, text="üîÑ Clear", width=80, 
                                     font=font_normal, command=self.clear_consumption_search)
        clear_button.pack(side="left", padx=5)
        
        cons_frame = ctk.CTkFrame(tab)
        cons_frame.pack(side="top", fill="both", expand=True, padx=10, pady=10)
        
        cons_columns = ("id", "month", "usage", "total_bill", "bill_status")
        self.cons_tree = ttk.Treeview(cons_frame, columns=cons_columns, show="headings") 
        self.cons_tree.heading("id", text="ID")
        self.cons_tree.heading("month", text="Month")
        self.cons_tree.heading("usage", text="Usage (kWh)")
        self.cons_tree.heading("total_bill", text="Bill (‚Çπ)")
        self.cons_tree.heading("bill_status", text="Status")
        self.cons_tree.column("id", width=50, stretch=False)
        self.cons_tree.column("month", width=100)
        self.cons_tree.column("usage", width=100)
        self.cons_tree.column("total_bill", width=100)
        self.cons_tree.column("bill_status", width=200)
        self.cons_tree.pack(side="left", fill="both", expand=True)
        
        cons_scrollbar = ttk.Scrollbar(cons_frame, orient="vertical", command=self.cons_tree.yview)
        self.cons_tree.configure(yscroll=cons_scrollbar.set)
        cons_scrollbar.pack(side="right", fill="y")
        
        edit_frame = ctk.CTkFrame(tab)
        edit_frame.pack(side="bottom", fill="x", padx=10, pady=10) 
        ctk.CTkLabel(edit_frame, text="Add / Edit Usage:", font=font_normal_bold).pack(side="left", padx=(5, 10))
        months = [f"{i:02d}" for i in range(1, 13)]
        self.month_menu = ctk.CTkOptionMenu(edit_frame, values=months, width=70, font=font_normal)
        self.month_menu.set("Month")
        self.month_menu.pack(side="left", padx=5)
        self.year_entry = ctk.CTkEntry(edit_frame, placeholder_text="Year (YYYY)", width=100, font=font_normal)
        self.year_entry.insert(0, str(datetime.now().year))
        self.year_entry.pack(side="left", padx=5)
        self.usage_entry = ctk.CTkEntry(edit_frame, placeholder_text="Usage (kWh)", width=100, font=font_normal)
        self.usage_entry.pack(side="left", padx=5)
        self.save_button = ctk.CTkButton(edit_frame, text="üíæ Save Usage", width=100, font=font_normal,
                                         command=self.save_client_usage)
        self.save_button.pack(side="left", padx=10)
        
        self.import_button = ctk.CTkButton(edit_frame, text="üì• Import CSV", width=140, font=font_normal,
                                          command=self.import_consumption_csv)
        self.import_button.pack(side="left", padx=10)
        
        self.export_cons_button = ctk.CTkButton(edit_frame, text="üì§ Export Excel", width=140, font=font_normal,
                                               command=self.export_consumption_to_excel)
        self.export_cons_button.pack(side="left", padx=10)
        
        self.delete_usage_button = ctk.CTkButton(edit_frame, text="üóëÔ∏è Delete Selected", width=140, font=font_normal,
                                                 fg_color="#D8000C", hover_color="#B0000A",
                                                 command=self.delete_selected_usage)
        self.delete_usage_button.pack(side="right", padx=10)

    def create_billing_tab(self, tab):
        font_normal = self.controller.font_normal
        font_normal_bold = self.controller.font_normal_bold
        
        top_bill_frame = ctk.CTkFrame(tab)
        top_bill_frame.pack(side="top", fill="x", padx=10, pady=10)
        
        ctk.CTkLabel(top_bill_frame, text="Select Client:", font=font_normal_bold).pack(side="left", padx=5)
        
        self.bill_client_select_menu = ctk.CTkComboBox(top_bill_frame, values=["Loading..."], 
                                                       font=font_normal, width=200,
                                                       command=self.admin_bill_client_selected)
        self.bill_client_select_menu.pack(side="left", padx=5)
        
        ctk.CTkLabel(top_bill_frame, text="Select Month:", font=font_normal_bold).pack(side="left", padx=10)
        
        self.bill_month_menu = ctk.CTkOptionMenu(top_bill_frame, values=["Select Client First"], font=font_normal,
                                                  command=self.display_admin_bill_preview)
        self.bill_month_menu.pack(side="left", padx=5)
        
        self.view_bill_button = ctk.CTkButton(top_bill_frame, text="üëÅÔ∏è View Full Bill", 
                                                font=font_normal, width=120,
                                                command=self.show_admin_bill_popup)
        self.view_bill_button.pack(side="left", padx=(20, 5))

        self.export_admin_bill_button = ctk.CTkButton(top_bill_frame, text="üìÑ Export to .txt", 
                                                      font=font_normal, width=120,
                                                      command=self.export_admin_bill_to_txt)
        self.export_admin_bill_button.pack(side="left", padx=(5, 5))
        
        bill_display_frame = ctk.CTkFrame(tab, fg_color="transparent")
        bill_display_frame.pack(side="top", fill="both", expand=True, padx=10, pady=10)
        
        self.admin_bill_textbox = ctk.CTkTextbox(bill_display_frame, font=self.controller.font_normal, height=400, width=600)
        self.admin_bill_textbox.pack(side="top", fill="both", expand=True)
        self.admin_bill_textbox.insert("1.0", "Please select a client to see available months.")
        self.admin_bill_textbox.configure(state="disabled")

    def create_analytics_tab(self, tab):
        font_normal_bold = self.controller.font_normal_bold
        tab.grid_columnconfigure(0, weight=1)
        tab.grid_columnconfigure(1, weight=1)
        tab.grid_rowconfigure(1, weight=1)
        ctk.CTkLabel(tab, text="Consumption by User", font=font_normal_bold).grid(row=0, column=0, pady=(10, 5))
        ctk.CTkLabel(tab, text="Total Monthly Usage", font=font_normal_bold).grid(row=0, column=1, pady=(10, 5))
        self.pie_chart_frame = ctk.CTkFrame(tab)
        self.pie_chart_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        self.line_chart_frame = ctk.CTkFrame(tab)
        self.line_chart_frame.grid(row=1, column=1, sticky="nsew", padx=10, pady=10)

    def create_compare_tab(self, tab):
        font_normal = self.controller.font_normal
        tab.grid_columnconfigure(0, weight=1)
        tab.grid_columnconfigure(1, weight=3)
        tab.grid_rowconfigure(1, weight=1) 
        
        compare_controls_frame = ctk.CTkFrame(tab)
        compare_controls_frame.grid(row=0, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        
        self.compare_search_entry = ctk.CTkEntry(compare_controls_frame, placeholder_text="Search clients...", font=font_normal)
        self.compare_search_entry.pack(side="left", padx=10, pady=10)
        self.compare_search_entry.bind("<KeyRelease>", self.filter_compare_list)
        
        compare_button = ctk.CTkButton(compare_controls_frame, text="üìà Generate Comparison",
                                          command=self.refresh_compare_graph)
        compare_button.pack(side="left", pady=10, padx=10)
        
        self.client_select_frame = ctk.CTkScrollableFrame(tab, label_text="Select Clients to Compare")
        self.client_select_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        self.client_checkbox_widgets = [] 

        self.compare_chart_frame = ctk.CTkFrame(tab)
        self.compare_chart_frame.grid(row=1, column=1, sticky="nsew", padx=10, pady=10)
        
        self.compare_canvas = None
        self.compare_fig = None
        
    def create_grievance_tab(self, tab):
        font_normal = self.controller.font_normal
        font_normal_bold = self.controller.font_normal_bold
        
        tab.grid_columnconfigure(0, weight=1)
        tab.grid_columnconfigure(1, weight=1)
        tab.grid_rowconfigure(1, weight=1)
        
        left_frame = ctk.CTkFrame(tab)
        left_frame.grid(row=0, column=0, rowspan=2, sticky="nsew", padx=10, pady=10)
        left_frame.grid_rowconfigure(1, weight=1)
        
        ctk.CTkLabel(left_frame, text="Grievance Tickets", font=font_normal_bold).pack(pady=5)
        
        grievance_controls_frame = ctk.CTkFrame(left_frame, fg_color="transparent")
        grievance_controls_frame.pack(fill="x", padx=5, pady=5)
        
        ctk.CTkLabel(grievance_controls_frame, text="Status:", font=font_normal).pack(side="left")
        self.grievance_status_filter = ctk.CTkOptionMenu(grievance_controls_frame, values=["All", "Pending", "Resolved"],
                                                         font=font_normal, command=self.refresh_grievance_list, width=120)
        self.grievance_status_filter.pack(side="left", padx=5)
        
        grievance_cols = ("token", "username", "subject", "status")
        self.grievance_tree = ttk.Treeview(left_frame, columns=grievance_cols, show="headings")
        self.grievance_tree.heading("token", text="Token")
        self.grievance_tree.heading("username", text="User")
        self.grievance_tree.heading("subject", text="Subject")
        self.grievance_tree.heading("status", text="Status")
        
        self.grievance_tree.column("token", width=80, stretch=False)
        self.grievance_tree.column("username", width=120)
        self.grievance_tree.column("subject", width=150)
        self.grievance_tree.column("status", width=100, stretch=False)
        
        self.grievance_tree.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        
        g_scrollbar = ttk.Scrollbar(left_frame, orient="vertical", command=self.grievance_tree.yview)
        self.grievance_tree.configure(yscroll=g_scrollbar.set)
        g_scrollbar.pack(side="right", fill="y")
        
        self.grievance_tree.bind("<<TreeviewSelect>>", self.load_grievance_messages)

        right_frame = ctk.CTkFrame(tab)
        right_frame.grid(row=0, column=1, rowspan=2, sticky="nsew", padx=10, pady=10)
        right_frame.grid_rowconfigure(0, weight=1)
        
        self.grievance_chat_label = ctk.CTkLabel(right_frame, text="Select a Ticket", font=font_normal_bold)
        self.grievance_chat_label.pack(pady=5)
        
        self.grievance_chat_box = ctk.CTkTextbox(right_frame, font=self.controller.font_normal, wrap="word")
        self.grievance_chat_box.pack(fill="both", expand=True, padx=5, pady=5)
        self.grievance_chat_box.configure(state="disabled")
        
        self.grievance_chat_box.tag_config("header", foreground="gray")
        self.grievance_chat_box.tag_config("message", spacing1=5, spacing3=15)
        
        self.grievance_reply_entry = ctk.CTkTextbox(right_frame, height=100, font=font_normal)
        self.grievance_reply_entry.pack(fill="x", padx=5, pady=(0, 5))
        
        reply_button_frame = ctk.CTkFrame(right_frame, fg_color="transparent")
        reply_button_frame.pack(fill="x", padx=5, pady=5)
        
        self.grievance_send_button = ctk.CTkButton(reply_button_frame, text="‚úâÔ∏è Send Reply", 
                                                    font=font_normal, command=self.send_grievance_reply)
        self.grievance_send_button.pack(side="left", padx=10)
        
        self.grievance_resolve_button = ctk.CTkButton(reply_button_frame, text="‚úîÔ∏è Mark as Resolved", 
                                                       font=font_normal, command=self.resolve_grievance)
        self.grievance_resolve_button.pack(side="right", padx=10)

    def create_log_tab(self, tab):
        font_normal = self.controller.font_normal
        
        log_filter_frame = ctk.CTkFrame(tab)
        log_filter_frame.pack(side="top", fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(log_filter_frame, text="Filter by User:", font=font_normal).pack(side="left", padx=5)
        self.log_user_filter = ctk.CTkComboBox(log_filter_frame, values=["All Users"], font=font_normal, width=200)
        self.log_user_filter.pack(side="left", padx=5)
        
        refresh_button = ctk.CTkButton(log_filter_frame, text="üîÑ Refresh Log", command=self.refresh_log_tab, font=font_normal)
        refresh_button.pack(side="left", padx=20)
        
        log_frame = ctk.CTkFrame(tab)
        log_frame.pack(side="top", fill="both", expand=True, padx=10, pady=10)
        log_columns = ("timestamp", "actor", "action")
        self.log_tree = ttk.Treeview(log_frame, columns=log_columns, show="headings")
        self.log_tree.heading("timestamp", text="Timestamp")
        self.log_tree.heading("actor", text="User")
        self.log_tree.heading("action", text="Action")
        self.log_tree.column("timestamp", width=160)
        self.log_tree.column("actor", width=120)
        self.log_tree.column("action", width=500)
        self.log_tree.pack(side="left", fill="both", expand=True)
        scrollbar = ttk.Scrollbar(log_frame, orient="vertical", command=self.log_tree.yview)
        self.log_tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side="right", fill="y")

    def open_change_password_dialog(self):
        if hasattr(self, 'password_dialog') and self.password_dialog.winfo_exists():
            self.password_dialog.focus()
        else:
            self.password_dialog = ChangePasswordDialog(parent=self, controller=self.controller)
            self.password_dialog.grab_set() 

    def add_user(self):
        name = self.user_name_entry.get()
        username = self.user_user_entry.get()
        password = self.user_pass_entry.get()
        role = self.role_menu.get() 
        if not name or not username or not password:
            messagebox.showerror("Error", "All fields are required.")
            return
        
        try:
            hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            db_query(
                "INSERT INTO users (username, password, role, full_name) VALUES (?, ?, ?, ?)",
                (username, hashed_password, role, name)
            )
            log_action(self.controller.current_user_name, f"Added new user: '{username}' (Role: {role}).")
            messagebox.showinfo("Success", f"User '{username}' added as {role}.")
            self.user_name_entry.delete(0, 'end')
            self.user_user_entry.delete(0, 'end')
            self.user_pass_entry.delete(0, 'end')
            self.refresh_data()
        except sqlite3.IntegrityError:
            messagebox.showerror("Error", "Username already exists.")
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")
            
    def remove_user(self):
        selected_item = self.user_tree.focus()
        if not selected_item:
            messagebox.showerror("Error", "Please select a user to remove.")
            return
        client_data = self.user_tree.item(selected_item)
        client_id = client_data['values'][0]
        client_name = client_data['values'][1]
        if client_id == self.controller.current_user_id:
            messagebox.showerror("Error", "You cannot remove your own account.")
            return
        if messagebox.askyesno("Confirm Delete", f"Are you sure you want to remove '{client_name}'? This will also delete all their consumption data."):
            try:
                db_query("DELETE FROM users WHERE id = ?", (client_id,))
                log_action(self.controller.current_user_name, f"Removed user: '{client_name}' (ID: {client_id}).")
                messagebox.showinfo("Success", f"User '{client_name}' removed.")
                self.refresh_data()
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")
    
    def open_update_user_dialog(self):
        selected_item = self.user_tree.focus()
        if not selected_item:
            messagebox.showerror("Error", "Please select a user to update.")
            return
        user_data = self.user_tree.item(selected_item)['values']
        user_id = user_data[0]
        username = user_data[1]
        full_name = user_data[2]
        
        if hasattr(self, 'update_user_dialog') and self.update_user_dialog.winfo_exists():
            self.update_user_dialog.focus()
        else:
            self.update_user_dialog = UpdateUserDialog(parent=self, controller=self.controller,
                                                       user_id=user_id, username=username, full_name=full_name)
            self.update_user_dialog.grab_set()

    def open_reset_password_dialog(self):
        selected_item = self.user_tree.focus()
        if not selected_item:
            messagebox.showerror("Error", "Please select a user.")
            return
        user_data = self.user_tree.item(selected_item)['values']
        user_id = user_data[0]
        username = user_data[1]
        
        if hasattr(self, 'reset_pass_dialog') and self.reset_pass_dialog.winfo_exists():
            self.reset_pass_dialog.focus()
        else:
            self.reset_pass_dialog = ResetPasswordDialog(parent=self, controller=self.controller,
                                                           user_id=user_id, username=username)
            self.reset_pass_dialog.grab_set()

    def export_users_to_excel(self):
        try:
            df = db_query_to_df("SELECT id, username, full_name, role FROM users")
            filename = filedialog.asksaveasfilename(defaultextension=".xlsx",
                                                      filetypes=[("Excel files", "*.xlsx")],
                                                      title="Save User List As")
            if not filename:
                return
            
            df.to_excel(filename, index=False, engine='openpyxl')
            log_action(self.controller.current_user_name, "Exported user list to Excel.")
            messagebox.showinfo("Success", f"User list exported successfully to:\n{filename}")
        except Exception as e:
            messagebox.showerror("Export Error", f"An error occurred: {e}")

    def upsert_consumption(self, client_id, db_month, usage_float):
        try:
            bill_data, _ = calculate_mahadiscom_bill(usage_float)
            total_bill = bill_data['F_Total_Bill']
            
            find_query = "SELECT id FROM consumption WHERE user_id = ? AND month = ?"
            existing_record = db_query_to_df(find_query, params=(client_id, db_month))
            
            if not existing_record.empty:
                record_id = existing_record.iloc[0]['id']
                update_query = "UPDATE consumption SET usage_kwh = ?, total_bill = ?, bill_status = 'Pending', payment_timestamp = NULL WHERE id = ?"
                db_query(update_query, params=(usage_float, total_bill, record_id))
                return "Updated"
            else:
                insert_query = "INSERT INTO consumption (user_id, month, usage_kwh, total_bill, bill_status) VALUES (?, ?, ?, ?, 'Pending')"
                db_query(insert_query, params=(client_id, db_month, usage_float, total_bill))
                return "Added"
        except sqlite3.IntegrityError:
            try:
                bill_data, _ = calculate_mahadiscom_bill(usage_float)
                total_bill = bill_data['F_Total_Bill']
                update_query = "UPDATE consumption SET usage_kwh = ?, total_bill = ?, bill_status = 'Pending', payment_timestamp = NULL WHERE user_id = ? AND month = ?"
                db_query(update_query, params=(usage_float, total_bill, client_id, db_month))
                return "Updated"
            except Exception as e:
                 raise Exception(f"Failed to update after integrity error: {e}")
        except Exception as e:
            raise e

    def save_client_usage(self):
        selected_client_name = self.client_select_menu.get()
        month = self.month_menu.get()
        year = self.year_entry.get()
        usage_str = self.usage_entry.get()
        
        if selected_client_name == "No Clients" or selected_client_name == "Loading..." or selected_client_name == "Select Client":
            messagebox.showerror("Error", "Please select a client from the dropdown first.")
            return
        if month == "Month" or not year or not usage_str:
            messagebox.showerror("Error", "Please fill in all fields: Month, Year, and Usage.")
            return
        try:
            usage_float = float(usage_str)
        except ValueError:
            messagebox.showerror("Error", "Usage must be a valid number (e.g., 150.5).")
            return
        if not (year.isdigit() and len(year) == 4):
            messagebox.showerror("Error", "Year must be a 4-digit number (e.g., 2025).")
            return
            
        try:
            client_id = self.client_map[selected_client_name]
            db_month = f"{year}-{month}"
            
            action = self.upsert_consumption(client_id, db_month, usage_float)
            
            log_action(self.controller.current_user_name, f"{action} usage for '{selected_client_name}' ({db_month}) to {usage_float} kWh.")
            messagebox.showinfo("Success", f"Usage {action.lower()} for {selected_client_name} for month {db_month}.")
            
            self.usage_entry.delete(0, 'end')
            self.month_menu.set("Month")
            self.refresh_data() 
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    def delete_selected_usage(self):
        selected_item = self.cons_tree.focus()
        if not selected_item:
            messagebox.showerror("Error", "Please select a consumption record to delete.")
            return
            
        record_data = self.cons_tree.item(selected_item)['values']
        record_id = record_data[0]
        record_month = record_data[1]
        client_name = self.client_select_menu.get()

        if messagebox.askyesno("Confirm Delete", f"Are you sure you want to delete the record for {client_name} for month {record_month}?"):
            try:
                db_query("DELETE FROM consumption WHERE id = ?", (record_id,))
                log_action(self.controller.current_user_name, f"Deleted usage record for {client_name} (Month: {record_month}, ID: {record_id}).")
                messagebox.showinfo("Success", "Usage record deleted.")
                self.refresh_data() 
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred: {e}")

    def import_consumption_csv(self):
        filename = filedialog.askopenfilename(filetypes=[("CSV files", "*.csv")],
                                               title="Select Consumption CSV")
        if not filename:
            return
            
        added_count = 0
        updated_count = 0
        failed_count = 0
        
        try:
            with open(filename, mode='r', encoding='utf-8-sig') as f:
                reader = csv.DictReader(f)
                
                for row in reader:
                    try:
                        user_id = int(row['user_id'])
                        month = row['month']
                        usage_kwh = float(row['usage_kwh'])
                        
                        action = self.upsert_consumption(user_id, month, usage_kwh)
                        if action == "Added":
                            added_count += 1
                        else:
                            updated_count += 1
                    except Exception as e:
                        print(f"Failed to process row: {row}. Error: {e}")
                        failed_count += 1
                        
            log_action(self.controller.current_user_name, f"Imported CSV: {added_count} added, {updated_count} updated, {failed_count} failed.")
            messagebox.showinfo("Import Complete", f"Import successful.\n\nAdded: {added_count}\nUpdated: {updated_count}\nFailed: {failed_count}")
            self.refresh_data()
            
        except Exception as e:
            messagebox.showerror("Import Error", f"An error occurred during import: {e}")

    def export_consumption_to_excel(self):
        try:
            df = db_query_to_df("""
                SELECT c.id, u.full_name, c.month, c.usage_kwh, c.total_bill, c.bill_status
                FROM consumption c
                JOIN users u ON c.user_id = u.id
                ORDER BY u.full_name, c.month
            """)
            filename = filedialog.asksaveasfilename(defaultextension=".xlsx",
                                                      filetypes=[("Excel files", "*.xlsx")],
                                                      title="Save Consumption Data As")
            if not filename:
                return
            
            df.to_excel(filename, index=False, engine='openpyxl')
            log_action(self.controller.current_user_name, "Exported consumption list to Excel.")
            messagebox.showinfo("Success", f"Consumption data exported successfully to:\n{filename}")
        except Exception as e:
            messagebox.showerror("Export Error", f"An error occurred: {e}")

    def show_admin_bill_popup(self):
        bill_text = self.admin_bill_textbox.get("1.0", "end-1c")
        if not bill_text or "Please select" in bill_text or "No consumption data" in bill_text:
            messagebox.showerror("Error", "Please generate a valid bill first.")
            return
        
        client_name = self.bill_client_select_menu.get()
        month = self.bill_month_menu.get()
        title = f"Bill for {client_name} - {month}"
        
        self.controller.show_bill_popup(bill_text, title=title)
        
    def export_admin_bill_to_txt(self):
        try:
            client_name = self.bill_client_select_menu.get()
            month = self.bill_month_menu.get()
            if client_name == "Select Client" or month in ["Select Client First", "No Data"]:
                messagebox.showerror("Error", "Cannot export. Please generate a valid bill first.")
                return
                
            text_to_save = self.admin_bill_textbox.get("1.0", "end-1c")
            clean_client_name = client_name.replace(" ", "_")
            filename = f"BILL_{clean_client_name}_{month}.txt"
            
            save_path = filedialog.asksaveasfilename(initialfile=filename,
                                                      defaultextension=".txt",
                                                      filetypes=[("Text files", "*.txt")],
                                                      title="Save Bill As")
            if not save_path:
                return

            with open(save_path, "w", encoding="utf-8") as f:
                f.write(text_to_save)
            
            log_action(self.controller.current_user_name, f"Exported bill for {client_name} ({month}).")
            messagebox.showinfo("Success", f"Bill exported successfully to:\n{save_path}")
        except Exception as e:
            messagebox.showerror("Export Error", f"An error occurred: {e}")

    def display_admin_bill_preview(self, selected_month):
        self.admin_bill_textbox.configure(state="normal")
        self.admin_bill_textbox.delete("1.0", "end")
        try:
            selected_client_name = self.bill_client_select_menu.get() 
            if selected_client_name == "Select Client" or selected_month == "Select Month" or selected_month == "No Data":
                self.admin_bill_textbox.insert("1.0", "Please select a client and a valid month.")
                self.admin_bill_textbox.configure(state="disabled")
                return
                
            client_id = self.client_map[selected_client_name]
            usage_df = db_query_to_df("SELECT usage_kwh FROM consumption WHERE user_id = ? AND month = ?", 
                                      params=(client_id, selected_month))
            if usage_df.empty:
                self.admin_bill_textbox.insert("1.0", f"No consumption data found for {selected_client_name} for {selected_month}.")
            else:
                kwh_units = usage_df['usage_kwh'].iloc[0]
                bill_text = self.controller.generate_bill_text(kwh_units, selected_month, selected_client_name)
                self.admin_bill_textbox.insert("1.0", bill_text)
        except Exception as e:
            self.admin_bill_textbox.insert("1.0", f"An error occurred: {e}")
        self.admin_bill_textbox.configure(state="disabled")

    def admin_bill_client_selected(self, selected_client_name):
        self.admin_bill_textbox.configure(state="normal")
        self.admin_bill_textbox.delete("1.0", "end")
        if selected_client_name in self.client_map:
            client_id = self.client_map[selected_client_name]
            data_df = db_query_to_df("SELECT month FROM consumption WHERE user_id = ? ORDER BY month DESC", params=(client_id,))
            available_months = list(data_df['month'])
            if not available_months:
                available_months = ["No Data"]
                self.admin_bill_textbox.insert("1.0", f"No consumption data found for {selected_client_name}.")
            else:
                self.admin_bill_textbox.insert("1.0", f"Please select a month for {selected_client_name} to generate a bill.")
            self.bill_month_menu.configure(values=available_months)
            self.bill_month_menu.set(available_months[0])
            self.display_admin_bill_preview(available_months[0])
        else:
            self.bill_month_menu.configure(values=["Select Client First"])
            self.bill_month_menu.set("Select Client First")
            self.admin_bill_textbox.insert("1.0", "Please select a client.")
        self.admin_bill_textbox.configure(state="disabled")

    def refresh_pie_chart(self):
        if self.pie_canvas:
            self.pie_canvas.get_tk_widget().destroy()
        query = """
        SELECT u.full_name, SUM(c.usage_kwh) as total_usage
        FROM consumption c JOIN users u ON c.user_id = u.id
        WHERE u.role = 'client' GROUP BY u.full_name
        """
        df = db_query_to_df(query)
        self.pie_fig = plt.Figure(figsize=(5, 4), dpi=100)
        self.pie_fig.set_facecolor(plt.rcParams['figure.facecolor'])
        ax = self.pie_fig.add_subplot(111)
        if df.empty or df['total_usage'].sum() == 0:
            ax.text(0.5, 0.5, "No client data", horizontalalignment='center', verticalalignment='center', color=plt.rcParams['text.color'])
        else:
            wedges, texts, autotexts = ax.pie(
                df['total_usage'], labels=df['full_name'], autopct='%1.1f%%',
                textprops={'color': plt.rcParams['text.color']}
            )
            ax.axis('equal')
        self.pie_canvas = FigureCanvasTkAgg(self.pie_fig, master=self.pie_chart_frame)
        self.pie_canvas.draw()
        self.pie_canvas.get_tk_widget().pack(side="top", fill="both", expand=True)
            
    def refresh_admin_line_graph(self):
        if self.line_canvas:
            self.line_canvas.get_tk_widget().destroy()
        query = "SELECT month, SUM(usage_kwh) as total_usage FROM consumption GROUP BY month ORDER BY month"
        df = db_query_to_df(query)
        self.line_fig = plt.Figure(figsize=(5, 4), dpi=100)
        self.line_fig.set_facecolor(plt.rcParams['figure.facecolor'])
        ax = self.line_fig.add_subplot(111)
        if df.empty:
            ax.text(0.5, 0.5, "No consumption data", horizontalalignment='center', verticalalignment='center', color=plt.rcParams['text.color'])
        else:
            ax.plot(df['month'], df['total_usage'], marker='o', color='#3b8ed0')
            ax.set_title("Total Site-Wide Usage (kWh)", color=plt.rcParams['text.color'])
            ax.set_xlabel("Month", color=plt.rcParams['axes.labelcolor'])
            ax.set_ylabel("Usage (kWh)", color=plt.rcParams['axes.labelcolor'])
            ax.set_facecolor(plt.rcParams['axes.facecolor'])
            for spine in ax.spines.values():
                spine.set_edgecolor(plt.rcParams['axes.edgecolor'])
            self.line_fig.tight_layout()
        self.line_canvas = FigureCanvasTkAgg(self.line_fig, master=self.line_chart_frame)
        self.line_canvas.draw()
        self.line_canvas.get_tk_widget().pack(side="top", fill="both", expand=True)

    def filter_compare_list(self, event=None):
        search_term = self.compare_search_entry.get().lower()
        for checkbox in self.client_checkbox_widgets:
            client_name = checkbox.cget("text").lower()
            if search_term in client_name:
                checkbox.pack(anchor="w", padx=10, pady=2)
            else:
                checkbox.pack_forget()

    def refresh_compare_client_list(self):
        for widget in self.client_select_frame.winfo_children():
            if not isinstance(widget, ctk.CTkButton):
                widget.destroy()
        self.client_checkbox_widgets = [] 
        
        clients_df = db_query_to_df("SELECT id, full_name FROM users WHERE role = 'client' ORDER BY full_name")
        for index, row in clients_df.iterrows():
            client_id = row['id']
            client_name = row['full_name']
            
            var = ctk.StringVar(value="off")
            cb = ctk.CTkCheckBox(self.client_select_frame, text=client_name,
                                 variable=var, onvalue=str(client_id), offvalue="off")
            cb.pack(anchor="w", padx=10, pady=2)
            self.client_checkbox_widgets.append(cb) 
        
        self.filter_compare_list()

    def refresh_compare_graph(self):
        if self.compare_canvas:
            self.compare_canvas.get_tk_widget().destroy()
            
        selected_client_ids = []
        for checkbox in self.client_checkbox_widgets:
            client_id_str = checkbox.get()
            if client_id_str != "off":
                selected_client_ids.append(int(client_id_str))
                
        self.compare_fig = plt.Figure(figsize=(8, 6), dpi=100)
        self.compare_fig.set_facecolor(plt.rcParams['figure.facecolor'])
        ax = self.compare_fig.add_subplot(111)
        
        if not selected_client_ids:
            ax.text(0.5, 0.5, "Please select clients from the list\nand click 'Generate Comparison'", 
                    horizontalalignment='center', verticalalignment='center', color=plt.rcParams['text.color'])
        else:
            prop_cycle = plt.rcParams['axes.prop_cycle']
            colors = prop_cycle.by_key()['color']
            client_data = {}
            
            for i, client_id in enumerate(selected_client_ids):
                query = "SELECT month, usage_kwh, u.full_name FROM consumption c JOIN users u ON c.user_id = u.id WHERE c.user_id = ? ORDER BY month"
                df = db_query_to_df(query, params=(client_id,))
                
                if not df.empty:
                    color = colors[i % len(colors)]
                    full_name = df['full_name'].iloc[0]
                    client_data[full_name] = df
                    ax.plot(df['month'], df['usage_kwh'], marker='o', label=full_name, color=color)

            if client_data:
                ax.set_title("Client Usage Comparison", color=plt.rcParams['text.color'])
                ax.set_xlabel("Month", color=plt.rcParams['axes.labelcolor'])
                ax.set_ylabel("Usage (kWh)", color=plt.rcParams['axes.labelcolor'])
                ax.set_facecolor(plt.rcParams['axes.facecolor'])
                for spine in ax.spines.values():
                    spine.set_edgecolor(plt.rcParams['axes.edgecolor'])
                ax.legend(facecolor=plt.rcParams['figure.facecolor'],
                          labelcolor=plt.rcParams['text.color'])
                self.compare_fig.tight_layout()
            else:
                 ax.text(0.5, 0.5, "No consumption data found\nfor the selected clients.", 
                    horizontalalignment='center', verticalalignment='center', color=plt.rcParams['text.color'])

        self.compare_canvas = FigureCanvasTkAgg(self.compare_fig, master=self.compare_chart_frame)
        self.compare_canvas.draw()
        self.compare_canvas.get_tk_widget().pack(side="top", fill="both", expand=True)

    def search_users(self):
        self.refresh_user_list()
        
    def clear_user_search(self):
        self.user_search_entry.delete(0, 'end')
        self.refresh_user_list()
        
    def filter_user_list_event(self, event):
        self.refresh_user_list()

    def sort_user_table(self, col):
        if self.user_sort_column == col:
            self.user_sort_reverse = not self.user_sort_reverse
        else:
            self.user_sort_column = col
            self.user_sort_reverse = False
        self.refresh_user_list()
            
    def sort_by_total_usage(self):
        self.user_search_entry.delete(0, 'end') 
        self.sort_user_table("total_usage")
            
    def refresh_user_list(self):
        for item in self.user_tree.get_children():
            self.user_tree.delete(item)
        
        search_term = self.user_search_entry.get()
        base_query = """
            SELECT u.id, u.username, u.full_name, u.role, COALESCE(SUM(c.usage_kwh), 0) as total_usage
            FROM users u
            LEFT JOIN consumption c ON u.id = c.user_id
        """
        params = []
        
        if search_term:
            base_query += " WHERE (u.username LIKE ? OR u.full_name LIKE ?)"
            search_like = f"%{search_term}%"
            params.extend([search_like, search_like])
        
        base_query += " GROUP BY u.id, u.username, u.full_name, u.role"
        
        sort_direction = "DESC" if self.user_sort_reverse else "ASC"
        sort_column = self.user_sort_column
        
        if sort_column == "total_usage":
            base_query += f" ORDER BY total_usage {sort_direction}"
        else:
            base_query += f" ORDER BY {sort_column} {sort_direction}"

        users_df = db_query_to_df(base_query, params=params)
        for index, user in users_df.iterrows():
            user_tuple = (
                user['id'], 
                user['username'], 
                user['full_name'], 
                user['role'],
                f"{user['total_usage']:.2f} kWh"
            )
            self.user_tree.insert("", "end", values=user_tuple)
            
    def refresh_consumption_data(self):
        clients_df = db_query_to_df("SELECT id, full_name FROM users WHERE role = 'client' ORDER BY full_name")
        self.client_map = {name: uid for uid, name in clients_df.values} 
        client_names = ["Select Client"] + list(self.client_map.keys())
        current_selection = self.client_select_menu.get()
        
        if len(client_names) <= 1:
            self.client_select_menu.configure(values=["No Clients"])
            self.client_select_menu.set("No Clients")
        else:
            self.client_select_menu.configure(values=client_names)
            if current_selection not in client_names:
                self.client_select_menu.set(client_names[0])
                
        self.load_client_consumption(self.client_select_menu.get())
        total_df = db_query_to_df("SELECT SUM(usage_kwh) as total FROM consumption")
        total_usage = total_df['total'].iloc[0] if total_df['total'].iloc[0] else 0.0
        self.total_label.configure(text=f"Total All Consumption: {total_usage:.2f} kWh")

    def search_consumption(self):
        self.load_client_consumption(self.client_select_menu.get(), search_term=self.month_search_entry.get())

    def clear_consumption_search(self):
        self.month_search_entry.delete(0, 'end')
        self.load_client_consumption(self.client_select_menu.get())

    def load_client_consumption(self, selected_client_name, search_term=None):
        for item in self.cons_tree.get_children():
            self.cons_tree.delete(item)
            
        if selected_client_name in self.client_map:
            client_id = self.client_map[selected_client_name]
            
            query = "SELECT id, month, usage_kwh, total_bill, bill_status, payment_timestamp FROM consumption WHERE user_id = ?"
            params = [client_id]
            
            if search_term:
                query += " AND month LIKE ?"
                params.append(f"%{search_term}%")
                
            query += " ORDER BY month DESC"
            
            data_df = db_query_to_df(query, params=params)
            
            if data_df.empty:
                self.consumption_stats_label.configure(text="Total: 0 kWh | Avg: 0 kWh/month")
            else:
                full_data_df = db_query_to_df("SELECT usage_kwh FROM consumption WHERE user_id = ?", params=(client_id,))
                total_usage = full_data_df['usage_kwh'].sum()
                avg_usage = full_data_df['usage_kwh'].mean()
                self.consumption_stats_label.configure(text=f"Total: {total_usage:.2f} kWh | Avg: {avg_usage:.2f} kWh/month")
                
                for index, row in data_df.iterrows():
                    if row['bill_status'] == 'Paid' and row['payment_timestamp']:
                        status = f"Paid on {row['payment_timestamp']}"
                    else:
                        status = "Pending"
                        
                    self.cons_tree.insert("", "end", values=(
                        row['id'], 
                        row['month'], 
                        f"{row['usage_kwh']:.2f}", 
                        f"{row['total_bill']:.2f}", 
                        status
                    ))
        else:
            self.consumption_stats_label.configure(text="Total: 0 kWh | Avg: 0 kWh/month")
    
    def refresh_admin_billing_tab_clients(self):
        clients_df = db_query_to_df("SELECT id, full_name FROM users WHERE role = 'client' ORDER BY full_name")
        self.client_map = {name: uid for uid, name in clients_df.values}
        client_names = ["Select Client"] + list(self.client_map.keys())
        
        self.bill_client_select_menu.configure(values=client_names)
        self.bill_client_select_menu.set("Select Client")
        self.bill_month_menu.configure(values=["Select Client First"])
        self.bill_month_menu.set("Select Client First")

    def refresh_log_tab(self):
        for item in self.log_tree.get_children():
            self.log_tree.delete(item)
        
        users_df = db_query_to_df("SELECT username FROM users ORDER BY username")
        user_list = ["All Users"] + list(users_df['username'])
        
        current_selection = self.log_user_filter.get()
        self.log_user_filter.configure(values=user_list)
        if current_selection in user_list:
            self.log_user_filter.set(current_selection)
        else:
            self.log_user_filter.set("All Users")
        
        selected_user = self.log_user_filter.get()
        
        base_query = "SELECT timestamp, actor, action FROM action_log"
        params = []
        
        if selected_user and selected_user != "All Users":
            base_query += " WHERE actor = ?"
            params.append(selected_user)
            
        base_query += " ORDER BY id DESC LIMIT 200"
        
        log_df = db_query_to_df(base_query, params=params)
        for index, log_entry in log_df.iterrows():
            self.log_tree.insert("", "end", values=tuple(log_entry))
    
    def refresh_grievance_list(self, filter_status=None):
        for item in self.grievance_tree.get_children():
            self.grievance_tree.delete(item)
            
        if filter_status is None:
            filter_status = self.grievance_status_filter.get()
            
        base_query = "SELECT token, created_at, username, subject, status, id FROM grievance_tickets"
        params = []
        
        if filter_status != "All":
            base_query += " WHERE status = ?"
            params.append(filter_status)
            
        base_query += " ORDER BY updated_at DESC"
        
        grievances_df = db_query_to_df(base_query, params=params)
        for index, row in grievances_df.iterrows():
            self.grievance_tree.insert("", "end", values=(row['token'], row['created_at'], row['username'], row['subject'], row['status']), iid=row['id'])
        
        self.grievance_chat_label.configure(text="Select a Ticket")
        self.grievance_reply_entry.delete("1.0", "end")
        self.grievance_chat_box.configure(state="normal")
        self.grievance_chat_box.delete("1.0", "end")
        self.grievance_chat_box.insert("1.0", "Select a grievance ticket from the list to view the chat.")
        self.grievance_chat_box.configure(state="disabled")

    def load_grievance_messages(self, event):
        selected_item_id = self.grievance_tree.focus()
        if not selected_item_id:
            return
            
        ticket_data = self.grievance_tree.item(selected_item_id)['values']
        subject = ticket_data[2]
        self.grievance_chat_label.configure(text=f"Ticket: {subject}")
        
        self.grievance_chat_box.configure(state="normal")
        self.grievance_chat_box.delete("1.0", "end")
        
        messages_df = db_query_to_df("SELECT sender_name, timestamp, message FROM grievance_messages WHERE ticket_id = ? ORDER BY timestamp ASC",
                                     params=(selected_item_id,))
        
        if messages_df.empty:
            self.grievance_chat_box.insert("1.0", "No messages found for this ticket.", ("header"))
        else:
            for index, row in messages_df.iterrows():
                header = f"--- {row['sender_name']} ({row['timestamp']}) ---\n"
                message = f"{row['message']}\n\n"
                
                self.grievance_chat_box.insert("end", header, ("header",))
                self.grievance_chat_box.insert("end", message, ("message",))

        self.grievance_chat_box.configure(state="disabled")
        self.grievance_chat_box.yview_moveto(1.0)
        
    def send_grievance_reply(self):
        selected_item_id = self.grievance_tree.focus()
        if not selected_item_id:
            messagebox.showerror("Error", "Please select a grievance to reply to.")
            return
            
        reply_text = self.grievance_reply_entry.get("1.0", "end-1c").strip()
        if not reply_text:
            messagebox.showerror("Error", "Please write a reply before sending.")
            return

        try:
            sender_id = self.controller.current_user_id
            sender_name = self.controller.current_user_name
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            db_query("INSERT INTO grievance_messages (ticket_id, sender_id, sender_name, message, timestamp) VALUES (?, ?, ?, ?, ?)",
                     (selected_item_id, sender_id, sender_name, reply_text, timestamp))
            
            db_query("UPDATE grievance_tickets SET status = 'Pending', updated_at = ? WHERE id = ?", (timestamp, selected_item_id))
            
            log_action(sender_name, f"Replied to grievance ticket ID {selected_item_id}.")
            self.grievance_reply_entry.delete("1.0", "end")
            self.load_grievance_messages(None)
            self.refresh_grievance_list()
                
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    def resolve_grievance(self):
        selected_item_id = self.grievance_tree.focus()
        if not selected_item_id:
            messagebox.showerror("Error", "Please select a grievance to resolve.")
            return
            
        grievance_data = self.grievance_tree.item(selected_item_id)['values']
        token = grievance_data[0]
        status = grievance_data[3]
        
        if status == "Resolved":
            messagebox.showinfo("Info", "This grievance is already marked as resolved.")
            return
            
        if messagebox.askyesno("Confirm", f"Are you sure you want to mark ticket {token} as 'Resolved'?"):
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            db_query("UPDATE grievance_tickets SET status = 'Resolved', updated_at = ? WHERE id = ?", (timestamp, selected_item_id))
            log_action(self.controller.current_user_name, f"Resolved grievance token {token}.")
            self.refresh_grievance_list()
    
    def update_charts(self):
        self.refresh_pie_chart()
        self.refresh_admin_line_graph()
        self.refresh_compare_client_list()
        self.refresh_compare_graph()

    def refresh_data(self):
        if not self.controller.current_user_id:
             return
        self.welcome_label.configure(text=f"Welcome, {self.controller.current_user_name} (Admin)")
        self.refresh_user_list() 
        self.refresh_consumption_data() 
        self.refresh_admin_billing_tab_clients() 
        self.update_charts() 
        self.refresh_log_tab()
        self.refresh_grievance_list()
class ClientView(ctk.CTkFrame):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        
        self.line_fig = None
        self.line_canvas = None
        
        font_normal = controller.font_normal
        font_bold = controller.font_bold
        font_normal_bold = controller.font_normal_bold
        
        change_pass_button = ctk.CTkButton(self, text="Change Password", command=self.open_change_password_dialog, width=140, font=font_normal)
        change_pass_button.place(relx=0.86, rely=0.02, anchor="ne")
        
        logout_button = ctk.CTkButton(self, text="Logout ‚û°Ô∏è", command=controller.logout, width=100, font=font_normal)
        logout_button.place(relx=0.98, rely=0.02, anchor="ne")
        
        self.welcome_label = ctk.CTkLabel(self, text="Client Dashboard", font=font_bold)
        self.welcome_label.place(relx=0.02, rely=0.02, anchor="nw")
        
        self.tab_view = ctk.CTkTabview(self)
        self.tab_view.place(relx=0.5, rely=0.53, relwidth=0.98, relheight=0.88, anchor="center")
        self.tab_view._segmented_button.configure(font=font_normal)
        
        self.tab_view.add("My Bills / History")
        self.tab_view.add("Billing Details")
        self.tab_view.add("Usage Graph")
        self.tab_view.add("‚úâÔ∏è Contact Admin")
        
        self.create_history_tab(self.tab_view.tab("My Bills / History"))
        self.create_billing_tab(self.tab_view.tab("Billing Details"))
        self.create_graph_tab(self.tab_view.tab("Usage Graph"))
        self.create_contact_tab(self.tab_view.tab("‚úâÔ∏è Contact Admin"))

    def open_change_password_dialog(self):
        if hasattr(self, 'password_dialog') and self.password_dialog.winfo_exists():
            self.password_dialog.focus()
        else:
            self.password_dialog = ChangePasswordDialog(parent=self, controller=self.controller)
            self.password_dialog.grab_set()

    def create_history_tab(self, tab):
        font_normal_bold = self.controller.font_normal_bold
        
        self.client_stats_label = ctk.CTkLabel(tab, text="Total: 0 kWh | Avg: 0 kWh/month", font=font_normal_bold)
        self.client_stats_label.pack(pady=5)
        
        cons_frame = ctk.CTkFrame(tab)
        cons_frame.pack(side="top", fill="both", expand=True, padx=10, pady=5)
        
        cons_columns = ("id", "month", "usage", "total_bill", "bill_status")
        self.cons_tree = ttk.Treeview(cons_frame, columns=cons_columns, show="headings") 
        self.cons_tree.heading("id", text="Bill ID")
        self.cons_tree.heading("month", text="Month")
        self.cons_tree.heading("usage", text="Usage (kWh)")
        self.cons_tree.heading("total_bill", text="Bill (‚Çπ)")
        self.cons_tree.heading("bill_status", text="Status")
        self.cons_tree.column("id", width=60, stretch=False)
        self.cons_tree.column("month", width=100)
        self.cons_tree.column("usage", width=100)
        self.cons_tree.column("total_bill", width=100)
        self.cons_tree.column("bill_status", width=200)
        
        self.cons_tree.pack(side="left", fill="both", expand=True)
        
        cons_scrollbar = ttk.Scrollbar(cons_frame, orient="vertical", command=self.cons_tree.yview)
        self.cons_tree.configure(yscroll=cons_scrollbar.set)
        cons_scrollbar.pack(side="right", fill="y")
        
        self.pay_bill_button = ctk.CTkButton(tab, text="üí∏ Pay Selected Bill", command=self.pay_selected_bill, font=self.controller.font_normal)
        self.pay_bill_button.pack(side="bottom", pady=10)

    def create_billing_tab(self, tab):
        font_normal_bold = self.controller.font_normal_bold
        font_normal = self.controller.font_normal

        bill_frame = ctk.CTkFrame(tab, fg_color="transparent")
        bill_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        client_bill_top = ctk.CTkFrame(bill_frame, fg_color="transparent")
        client_bill_top.pack(side="top", fill="x", pady=(0, 10))
        
        ctk.CTkLabel(client_bill_top, text="Select Billing Month:", font=font_normal_bold).pack(side="left", padx=5)
        
        self.client_month_menu = ctk.CTkOptionMenu(client_bill_top, values=["No Data"], font=font_normal,
                                                   command=self.generate_client_bill_preview)
        self.client_month_menu.pack(side="left", padx=5)
        
        self.client_view_bill_button = ctk.CTkButton(client_bill_top, text="üëÅÔ∏è View Full Bill",
                                                       font=font_normal, width=120,
                                                       command=self.show_client_bill_popup)
        self.client_view_bill_button.pack(side="left", padx=(20, 5))

        self.export_client_bill_button = ctk.CTkButton(client_bill_top, text="üìÑ Export to .txt",
                                                       font=font_normal, width=120,
                                                       command=self.export_client_bill_to_txt)
        self.export_client_bill_button.pack(side="left", padx=(5, 5))
        
        self.client_bill_textbox = ctk.CTkTextbox(bill_frame, font=self.controller.font_normal)
        self.client_bill_textbox.pack(fill="both", expand=True)
        self.client_bill_textbox.configure(state="disabled")

    def create_graph_tab(self, tab):
        font_normal_bold = self.controller.font_normal_bold
        self.graph_frame = ctk.CTkFrame(tab)
        self.graph_frame.pack(side="top", fill="both", expand=True, padx=10, pady=10)
        ctk.CTkLabel(self.graph_frame, text="Your Personal Usage (kWh)", font=font_normal_bold).pack(pady=10)
        
    def create_contact_tab(self, tab):
        font_normal = self.controller.font_normal
        font_normal_bold = self.controller.font_normal_bold

        contact_tabs = ctk.CTkTabview(tab)
        contact_tabs.pack(fill="both", expand=True, padx=5, pady=5)
        contact_tabs.add("Submit New Ticket")
        contact_tabs.add("View My Tickets")
        
        submit_tab = contact_tabs.tab("Submit New Ticket")
        
        ctk.CTkLabel(submit_tab, text="Subject:", font=font_normal_bold).pack(anchor="w", padx=10, pady=(10, 0))
        self.grievance_subject_entry = ctk.CTkEntry(submit_tab, placeholder_text="e.g., Incorrect bill for 2025-10", font=font_normal)
        self.grievance_subject_entry.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(submit_tab, text="Message:", font=font_normal_bold).pack(anchor="w", padx=10, pady=5)
        self.grievance_body_entry = ctk.CTkTextbox(submit_tab, font=font_normal, height=200)
        self.grievance_body_entry.pack(fill="both", expand=True, padx=10, pady=5)
        
        submit_button = ctk.CTkButton(submit_tab, text="‚úâÔ∏è Submit Ticket", font=font_normal_bold, 
                                      command=self.submit_grievance)
        submit_button.pack(pady=10)
        
        view_tab = contact_tabs.tab("View My Tickets")
        
        ticket_cols = ("token", "created_at", "subject", "status")
        self.ticket_tree = ttk.Treeview(view_tab, columns=ticket_cols, show="headings")
        self.ticket_tree.heading("token", text="Token ID")
        self.ticket_tree.heading("created_at", text="Date")
        self.ticket_tree.heading("subject", text="Subject")
        self.ticket_tree.heading("status", text="Status")
        
        self.ticket_tree.column("token", width=80)
        self.ticket_tree.column("created_at", width=150)
        self.ticket_tree.column("subject", width=300)
        self.ticket_tree.column("status", width=100)
        
        self.ticket_tree.pack(side="left", fill="both", expand=True, padx=10, pady=10)
        
        ticket_scrollbar = ttk.Scrollbar(view_tab, orient="vertical", command=self.ticket_tree.yview)
        self.ticket_tree.configure(yscroll=ticket_scrollbar.set)
        ticket_scrollbar.pack(side="right", fill="y")
        
        view_details_button = ctk.CTkButton(view_tab, text="üëÅÔ∏è View Chat", font=font_normal,
                                            command=self.view_ticket_details)
        view_details_button.pack(pady=10)

    def submit_grievance(self):
        subject = self.grievance_subject_entry.get()
        body = self.grievance_body_entry.get("1.0", "end-1c").strip()
        
        if not subject or not body:
            messagebox.showerror("Error", "Please fill in both the Subject and Message fields.")
            return
            
        try:
            user_id = self.controller.current_user_id
            username = self.controller.current_user_name
            token = f"T-{random.randint(100000, 999999)}"
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            ticket_id = db_query_lastrowid("INSERT INTO grievance_tickets (token, user_id, username, subject, status, created_at, updated_at) VALUES (?, ?, ?, ?, 'Pending', ?, ?)",
                                          (token, user_id, username, subject, timestamp, timestamp))
            
            if ticket_id is None:
                messagebox.showerror("Error", "Failed to create grievance ticket.")
                return

            db_query("INSERT INTO grievance_messages (ticket_id, sender_id, sender_name, message, timestamp) VALUES (?, ?, ?, ?, ?)",
                     (ticket_id, user_id, username, body, timestamp))
                     
            log_action(username, f"Submitted new grievance (Token: {token}).")
            messagebox.showinfo("Success", f"Your grievance has been submitted successfully.\n\nYour Token ID is: {token}\n\nAn admin will review it shortly.")
            
            self.grievance_subject_entry.delete(0, 'end')
            self.grievance_body_entry.delete("1.0", "end")
            self.refresh_grievance_list()
            self.tab_view.set("View My Tickets")
            
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}")

    def refresh_grievance_list(self):
        if not hasattr(self, 'ticket_tree'):
            return 
            
        for item in self.ticket_tree.get_children():
            self.ticket_tree.delete(item)
            
        user_id = self.controller.current_user_id
        if not user_id:
            return
            
        tickets_df = db_query_to_df("SELECT token, created_at, subject, status, id FROM grievance_tickets WHERE user_id = ? ORDER BY updated_at DESC", 
                                  params=(user_id,))
        
        for index, row in tickets_df.iterrows():
            self.ticket_tree.insert("", "end", values=(row['token'], row['created_at'], row['subject'], row['status']), iid=row['id'])

    def view_ticket_details(self):
        selected_item_id = self.ticket_tree.focus()
        if not selected_item_id:
            messagebox.showerror("Error", "Please select a ticket to view.")
            return
            
        ticket_data = self.ticket_tree.item(selected_item_id)['values']
        subject = ticket_data[2]
        
        self.controller.show_grievance_popup(
            ticket_id=selected_item_id,
            subject=subject
        )

    def refresh_client_table(self):
        for item in self.cons_tree.get_children():
            self.cons_tree.delete(item)
        user_id = self.controller.current_user_id
        if not user_id: return
        
        data_df = db_query_to_df("SELECT id, month, usage_kwh, total_bill, bill_status, payment_timestamp FROM consumption WHERE user_id = ? ORDER BY month DESC", params=(user_id,))
        
        if data_df.empty:
            self.cons_tree.insert("", "end", values=("", "No consumption data found.", "", "", ""))
            self.client_stats_label.configure(text="Total: 0 kWh | Avg: 0 kWh/month")
        else:
            total_usage = data_df['usage_kwh'].sum()
            avg_usage = data_df['usage_kwh'].mean()
            self.client_stats_label.configure(text=f"Total: {total_usage:.2f} kWh | Avg: {avg_usage:.2f} kWh/month")
            
            for index, row in data_df.iterrows():
                if row['bill_status'] == 'Paid' and row['payment_timestamp']:
                    status = f"Paid on {row['payment_timestamp']}"
                else:
                    status = "Pending"
                    
                self.cons_tree.insert("", "end", values=(
                    row['id'], 
                    row['month'], 
                    f"{row['usage_kwh']:.2f}", 
                    f"{row['total_bill']:.2f}", 
                    status
                ))
    
    def pay_selected_bill(self):
        selected_item = self.cons_tree.focus()
        if not selected_item:
            messagebox.showerror("Error", "Please select a bill from the table to pay.")
            return
            
        bill_data = self.cons_tree.item(selected_item)['values']
        bill_id = bill_data[0]
        bill_month = bill_data[1]
        bill_amount = bill_data[3]
        bill_status = bill_data[4]
        
        if "Paid" in bill_status:
            messagebox.showinfo("Info", "This bill has already been paid.")
            return
            
        if messagebox.askyesno("Confirm Payment", f"Do you want to pay ‚Çπ{bill_amount} for the bill from {bill_month}?"):
            try:
                paid_timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                db_query("UPDATE consumption SET bill_status = 'Paid', payment_timestamp = ? WHERE id = ?", (paid_timestamp, bill_id))
                
                log_action(self.controller.current_user_name, f"Paid bill for {bill_month} (ID: {bill_id}).")
                messagebox.showinfo("Success", "Payment successful! The bill status has been updated.")
                self.refresh_data()
            except Exception as e:
                messagebox.showerror("Error", f"An error occurred while updating payment status: {e}")

    def show_client_bill_popup(self):
        bill_text = self.client_bill_textbox.get("1.0", "end-1c")
        if not bill_text or "Please select" in bill_text or "No consumption data" in bill_text:
            messagebox.showerror("Error", "Please select a valid month to view the bill.")
            return
        
        month = self.client_month_menu.get()
        title = f"Your Bill - {month}"
        self.controller.show_bill_popup(bill_text, title=title)

    def export_client_bill_to_txt(self):
        try:
            client_name = self.controller.current_user_name
            month = self.client_month_menu.get()
            if month == "No Data":
                messagebox.showerror("Error", "Cannot export. No bill data available.")
                return
                
            text_to_save = self.client_bill_textbox.get("1.0", "end-1c")
            clean_client_name = client_name.replace(" ", "_")
            filename = f"BILL_{clean_client_name}_{month}.txt"
            
            save_path = filedialog.asksaveasfilename(initialfile=filename,
                                                      defaultextension=".txt",
                                                      filetypes=[("Text files", "*.txt")],
                                                      title="Save Bill As")
            if not save_path:
                return
                
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(text_to_save)
            log_action(client_name, f"Exported their own bill ({month}).")
            messagebox.showinfo("Success", f"Bill exported successfully to:\n{save_path}")
        except Exception as e:
            messagebox.showerror("Export Error", f"An error occurred: {e}")

    def generate_client_bill_preview(self, selected_month):
        self.client_bill_textbox.configure(state="normal")
        self.client_bill_textbox.delete("1.0", "end")
        
        user_id = self.controller.current_user_id
        if not user_id:
            self.client_bill_textbox.insert("1.0", "Error: Not logged in.")
            self.client_bill_textbox.configure(state="disabled")
            return

        if selected_month == "No Data":
            self.client_bill_textbox.insert("1.0", "No consumption data found to generate a bill.")
            self.client_bill_textbox.configure(state="disabled")
            return
            
        data_df = db_query_to_df("SELECT usage_kwh FROM consumption WHERE user_id = ? AND month = ?", params=(user_id, selected_month))
        
        if data_df.empty:
            self.client_bill_textbox.insert("1.0", f"Error: No data found for month {selected_month}.")
        else:
            kwh_units = data_df['usage_kwh'].iloc[0]
            user_name = self.controller.current_user_name
            bill_text = self.controller.generate_bill_text(kwh_units, selected_month, user_name)
            self.client_bill_textbox.insert("1.0", bill_text)
            
        self.client_bill_textbox.configure(state="disabled")

    def refresh_billing_tab(self):
        user_id = self.controller.current_user_id
        if not user_id: return
        
        data_df = db_query_to_df("SELECT month FROM consumption WHERE user_id = ? ORDER BY month DESC", params=(user_id,))
        available_months = list(data_df['month'])
        
        if not available_months:
            self.client_month_menu.configure(values=["No Data"])
            self.client_month_menu.set("No Data")
            self.generate_client_bill_preview("No Data")
        else:
            self.client_month_menu.configure(values=available_months)
            self.client_month_menu.set(available_months[0])
            self.generate_client_bill_preview(available_months[0])
                
    def refresh_client_line_graph(self):
        if self.line_canvas:
            self.line_canvas.get_tk_widget().destroy()

        user_id = self.controller.current_user_id
        if not user_id: return

        query = "SELECT month, usage_kwh FROM consumption WHERE user_id = ? ORDER BY month"
        df = db_query_to_df(query, params=(user_id,))
        
        self.line_fig = plt.Figure(figsize=(5, 4), dpi=100)
        self.line_fig.set_facecolor(plt.rcParams['figure.facecolor'])
        ax = self.line_fig.add_subplot(111)
        
        if df.empty:
            ax.text(0.5, 0.5, "No consumption data", horizontalalignment='center', verticalalignment='center', color=plt.rcParams['text.color'])
        else:
            ax.plot(df['month'], df['usage_kwh'], marker='o', color='#3b8ed0')
            ax.set_xlabel("Month", color=plt.rcParams['axes.labelcolor'])
            ax.set_ylabel("Usage (kWh)", color=plt.rcParams['axes.labelcolor'])
            ax.set_facecolor(plt.rcParams['axes.facecolor'])
            for spine in ax.spines.values():
                spine.set_edgecolor(plt.rcParams['axes.edgecolor'])
            self.line_fig.tight_layout() 
            
        self.line_canvas = FigureCanvasTkAgg(self.line_fig, master=self.graph_frame)
        self.line_canvas.draw()
        self.line_canvas.get_tk_widget().pack(side="top", fill="both", expand=True)
        
    def update_charts(self):
        if self.controller.current_user_id: 
            self.refresh_client_line_graph()

    def refresh_data(self):
        if not self.controller.current_user_id:
            return 
        self.welcome_label.configure(text=f"Welcome, {self.controller.current_user_name}")
        self.refresh_client_table()
        self.refresh_billing_tab()
        self.refresh_client_line_graph()
        self.refresh_grievance_list()

class ChangePasswordDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        
        self.title("Change Password")
        self.geometry("350x300")
        
        self.font_normal = self.controller.font_normal
        self.font_bold = self.controller.font_bold_large

        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        ctk.CTkLabel(main_frame, text="Change Your Password", font=self.font_bold).pack(pady=(0, 15))
        
        ctk.CTkLabel(main_frame, text="Current Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.current_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.current_pass_entry.pack(pady=(0, 10), padx=10)
        
        ctk.CTkLabel(main_frame, text="New Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.new_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.new_pass_entry.pack(pady=(0, 10), padx=10)

        ctk.CTkLabel(main_frame, text="Confirm New Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.confirm_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.confirm_pass_entry.pack(pady=(0, 20), padx=10)
        
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack()

        save_button = ctk.CTkButton(button_frame, text="Save Password", command=self.save_password)
        save_button.pack(side="left", padx=10)
        
        cancel_button = ctk.CTkButton(button_frame, text="Cancel", command=self.destroy, fg_color="gray")
        cancel_button.pack(side="left", padx=10)
        
        self.after(100, self.lift) 
        self.grab_set()
        self.current_pass_entry.focus()

    def save_password(self):
        current_pass = self.current_pass_entry.get()
        new_pass = self.new_pass_entry.get()
        confirm_pass = self.confirm_pass_entry.get()
        
        if not current_pass or not new_pass or not confirm_pass:
            messagebox.showerror("Error", "All fields are required.", parent=self)
            return
        if new_pass != confirm_pass:
            messagebox.showerror("Error", "New passwords do not match.", parent=self)
            return
        if current_pass == new_pass:
            messagebox.showerror("Error", "New password must be different from the current password.", parent=self)
            return

        user_id = self.controller.current_user_id
        user_df = db_query_to_df("SELECT password FROM users WHERE id = ?", params=(user_id,))
        
        if user_df.empty:
            messagebox.showerror("Error", "Could not find user record.", parent=self)
            return
            
        stored_hash = user_df.iloc[0]['password'].encode('utf-8')
        
        if not bcrypt.checkpw(current_pass.encode('utf-8'), stored_hash):
            messagebox.showerror("Error", "Your 'Current Password' is incorrect.", parent=self)
            log_action(self.controller.current_user_name, "Failed password change (wrong current pass).")
            return
            
        try:
            new_hashed_pass = bcrypt.hashpw(new_pass.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            db_query("UPDATE users SET password = ? WHERE id = ?", (new_hashed_pass, user_id))
            
            log_action(self.controller.current_user_name, "Changed their password successfully.")
            messagebox.showinfo("Success", "Password changed successfully.", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}", parent=self)

class ResetPasswordDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller, user_id, username):
        super().__init__(parent)
        self.controller = controller
        self.user_id = user_id
        
        self.title("Reset Password")
        self.geometry("350x250")
        
        self.font_normal = self.controller.font_normal
        self.font_bold = self.controller.font_bold_large

        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        ctk.CTkLabel(main_frame, text="Reset Password", font=self.font_bold).pack(pady=(0, 10))
        ctk.CTkLabel(main_frame, text=f"User: {username}", font=self.font_normal).pack(pady=(0, 15))
        
        ctk.CTkLabel(main_frame, text="New Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.new_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.new_pass_entry.pack(pady=(0, 10), padx=10)

        ctk.CTkLabel(main_frame, text="Confirm New Password:", font=self.font_normal).pack(anchor="w", padx=10)
        self.confirm_pass_entry = ctk.CTkEntry(main_frame, show="*", width=250)
        self.confirm_pass_entry.pack(pady=(0, 20), padx=10)
        
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack()

        save_button = ctk.CTkButton(button_frame, text="Set Password", command=self.save_password)
        save_button.pack(side="left", padx=10)
        
        cancel_button = ctk.CTkButton(button_frame, text="Cancel", command=self.destroy, fg_color="gray")
        cancel_button.pack(side="left", padx=10)
        
        self.after(100, self.lift) 
        self.grab_set()
        self.new_pass_entry.focus()

    def save_password(self):
        new_pass = self.new_pass_entry.get()
        confirm_pass = self.confirm_pass_entry.get()
        
        if not new_pass or not confirm_pass:
            messagebox.showerror("Error", "All fields are required.", parent=self)
            return
        if new_pass != confirm_pass:
            messagebox.showerror("Error", "New passwords do not match.", parent=self)
            return
            
        try:
            new_hashed_pass = bcrypt.hashpw(new_pass.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            db_query("UPDATE users SET password = ? WHERE id = ?", (new_hashed_pass, self.user_id))
            
            log_action(self.controller.current_user_name, f"Reset password for user ID {self.user_id}.")
            messagebox.showinfo("Success", "Password has been reset successfully.", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}", parent=self)

class UpdateUserDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller, user_id, username, full_name):
        super().__init__(parent)
        self.controller = controller
        self.user_id = user_id
        
        self.title("Update User Info")
        self.geometry("350x250")
        
        self.font_normal = self.controller.font_normal
        self.font_bold = self.controller.font_bold_large

        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        ctk.CTkLabel(main_frame, text="Update User Info", font=self.font_bold).pack(pady=(0, 15))
        
        ctk.CTkLabel(main_frame, text="Full Name:", font=self.font_normal).pack(anchor="w", padx=10)
        self.full_name_entry = ctk.CTkEntry(main_frame, width=250)
        self.full_name_entry.insert(0, full_name)
        self.full_name_entry.pack(pady=(0, 10), padx=10)

        ctk.CTkLabel(main_frame, text="Username:", font=self.font_normal).pack(anchor="w", padx=10)
        self.username_entry = ctk.CTkEntry(main_frame, width=250)
        self.username_entry.insert(0, username)
        self.username_entry.pack(pady=(0, 20), padx=10)
        
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack()

        save_button = ctk.CTkButton(button_frame, text="Save Changes", command=self.save_changes)
        save_button.pack(side="left", padx=10)
        
        cancel_button = ctk.CTkButton(button_frame, text="Cancel", command=self.destroy, fg_color="gray")
        cancel_button.pack(side="left", padx=10)
        
        self.after(100, self.lift)
        self.grab_set()
        self.full_name_entry.focus()

    def save_changes(self):
        new_full_name = self.full_name_entry.get()
        new_username = self.username_entry.get()
        
        if not new_full_name or not new_username:
            messagebox.showerror("Error", "All fields are required.", parent=self)
            return
            
        try:
            db_query("UPDATE users SET full_name = ?, username = ? WHERE id = ?", (new_full_name, new_username, self.user_id))
            log_action(self.controller.current_user_name, f"Updated info for user ID {self.user_id}.")
            messagebox.showinfo("Success", "User information updated successfully.", parent=self)
            self.controller.frames["AdminView"].refresh_user_list()
            self.destroy()
        except sqlite3.IntegrityError:
            messagebox.showerror("Error", "That username is already taken.", parent=self)
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}", parent=self)

class BillViewDialog(ctk.CTkToplevel):
    def __init__(self, parent, title, bill_text):
        super().__init__(parent)
        self.title(title)
        self.geometry("600x700")
        
        font_mono = ctk.CTkFont(family="Courier", size=14)
        
        textbox = ctk.CTkTextbox(self, font=font_mono, wrap="word")
        textbox.pack(fill="both", expand=True, padx=10, pady=10)
        
        textbox.insert("1.0", bill_text)
        textbox.configure(state="disabled")
        
        close_button = ctk.CTkButton(self, text="Close", command=self.destroy)
        close_button.pack(pady=10)
        
        self.after(100, self.lift)
        self.grab_set()

class GrievanceViewDialog(ctk.CTkToplevel):
    def __init__(self, parent, controller, ticket_id, subject):
        super().__init__(parent)
        self.controller = controller
        self.ticket_id = ticket_id
        
        self.title(f"Ticket: {subject}")
        self.geometry("500x600")
        
        self.font_normal = self.controller.font_normal
        self.font_bold = self.controller.font_normal_bold
        self.font_small = self.controller.font_small

        self.chat_frame_wrapper = ctk.CTkFrame(self, fg_color="transparent")
        self.chat_frame_wrapper.pack(fill="both", expand=True, padx=10, pady=10)
        self.chat_frame_wrapper.grid_rowconfigure(0, weight=1)
        self.chat_frame_wrapper.grid_columnconfigure(0, weight=1)

        self.chat_frame = ctk.CTkScrollableFrame(self.chat_frame_wrapper)
        self.chat_frame.grid(row=0, column=0, sticky="nsew")

        self.reply_entry = ctk.CTkTextbox(self, height=100, font=self.font_normal)
        self.reply_entry.pack(fill="x", padx=10, pady=(0, 5))
        
        self.send_button = ctk.CTkButton(self, text="‚úâÔ∏è Send Reply", font=self.font_normal, command=self.send_reply)
        self.send_button.pack(pady=(0, 10))
        
        self.chat_frame.bind_all("<MouseWheel>", lambda event: self.chat_frame._parent_canvas.yview_scroll(int(-1*(event.delta/120)), "units"), add="+")

        self.load_chat_history()
        self.check_ticket_status()
        
        self.after(100, self.lift)
        self.grab_set()
        
    def load_chat_history(self):
        for widget in self.chat_frame.winfo_children():
            widget.destroy()
            
        messages_df = db_query_to_df("SELECT sender_name, timestamp, message FROM grievance_messages WHERE ticket_id = ? ORDER BY timestamp ASC",
                                     params=(self.ticket_id,))
        
        if messages_df.empty:
            ctk.CTkLabel(self.chat_frame, text="No messages found for this ticket.", font=self.font_normal).pack(anchor="w")
        else:
            for index, row in messages_df.iterrows():
                header = f"--- {row['sender_name']} ({row['timestamp']}) ---\n"
                message = f"{row['message']}\n\n"
                
                msg_frame = ctk.CTkFrame(self.chat_frame, fg_color="transparent")
                msg_label = ctk.CTkLabel(msg_frame, text=header+message, font=self.font_normal, justify="left", wraplength=400)
                
                if row['sender_name'] == self.controller.current_user_name:
                    msg_label.pack(anchor="e", padx=5, pady=0)
                    msg_frame.pack(fill="x", anchor="e", padx=5, pady=2)
                else:
                    msg_label.pack(anchor="w", padx=5, pady=0)
                    msg_frame.pack(fill="x", anchor="w", padx=5, pady=2)

        self.after(100, self.chat_frame._parent_canvas.yview_moveto, 1.0)

    def send_reply(self):
        reply_text = self.reply_entry.get("1.0", "end-1c").strip()
        if not reply_text:
            messagebox.showerror("Error", "Cannot send an empty message.", parent=self)
            return
            
        try:
            sender_id = self.controller.current_user_id
            sender_name = self.controller.current_user_name
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            db_query("INSERT INTO grievance_messages (ticket_id, sender_id, sender_name, message, timestamp) VALUES (?, ?, ?, ?, ?)",
                     (self.ticket_id, sender_id, sender_name, reply_text, timestamp))
            
            # If an admin replies, set to Pending. If a client replies, set to Pending.
            # Only the "Resolve" button should set it to Resolved.
            db_query("UPDATE grievance_tickets SET status = 'Pending', updated_at = ? WHERE id = ?", (timestamp, self.ticket_id))
            
            log_action(sender_name, f"Replied to grievance ticket ID {self.ticket_id}.")
            self.reply_entry.delete("1.0", "end")
            self.load_chat_history()
            
            if self.controller.current_user_role == 'admin':
                self.controller.frames["AdminView"].refresh_grievance_list()
            else:
                self.controller.frames["ClientView"].refresh_grievance_list()
                
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {e}", parent=self)

    def check_ticket_status(self):
        status_df = db_query_to_df("SELECT status FROM grievance_tickets WHERE id = ?", params=(self.ticket_id,))
        if not status_df.empty and status_df.iloc[0]['status'] == 'Resolved':
            self.reply_entry.insert("1.0", "This ticket is marked as 'Resolved' and can no longer be replied to.")
            self.reply_entry.configure(state="disabled")
            self.send_button.configure(state="disabled")


if __name__ == "__main__":
    ctk.set_default_color_theme("blue")
    
    setup_database()
    
    app = ElectricityPortalApp()
    app.mainloop()